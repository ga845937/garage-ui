// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v5.29.3
// source: object.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";

export const protobufPackage = "object";

export interface ListObjectsResponse {
  trace_id: string;
  data: ObjectInfo[];
  next_continuation_token?: string | undefined;
  is_truncated: boolean;
}

export interface ObjectMetadataResponse {
  trace_id: string;
  data: ObjectMetadata | undefined;
}

export interface UploadObjectResponse {
  trace_id: string;
  data: UploadResult | undefined;
}

export interface DeleteObjectResponse {
  trace_id: string;
  deleted: string[];
  errors: DeleteError[];
}

export interface CopyObjectResponse {
  trace_id: string;
  data: CopyResult | undefined;
}

export interface AbortUploadResponse {
  trace_id: string;
  success: boolean;
  bucket: string;
  key: string;
  upload_id: string;
}

export interface PreSignedUrlResponse {
  trace_id: string;
  data: PreSignedUrl | undefined;
}

export interface ListObjectsRequest {
  bucket: string;
  prefix?: string | undefined;
  continuation_token?: string | undefined;
  max_keys?: number | undefined;
}

export interface GetObjectMetadataRequest {
  bucket: string;
  key: string;
}

/** Upload request - first message must be metadata, followed by chunks */
export interface UploadChunkRequest {
  /** First message: upload metadata */
  metadata?:
    | UploadMetadata
    | undefined;
  /** Subsequent messages: file chunks */
  chunk?: Uint8Array | undefined;
}

export interface UploadMetadata {
  bucket: string;
  key: string;
  content_type: string;
  content_length: number;
}

/** Upload response - server sends upload_id after receiving metadata, then final result */
export interface UploadChunkResponse {
  trace_id: string;
  /** First response: upload initiated with upload_id */
  initiated?:
    | UploadInitiated
    | undefined;
  /** Progress update (optional) */
  progress?:
    | UploadProgress
    | undefined;
  /** Final response: upload completed */
  result?: UploadResult | undefined;
}

/** Sent after receiving metadata, before chunks */
export interface UploadInitiated {
  upload_id: string;
  bucket: string;
  key: string;
}

/** Optional progress update */
export interface UploadProgress {
  part_number: number;
  bytes_uploaded: number;
  total_bytes: number;
}

export interface DownloadObjectRequest {
  bucket: string;
  key: string;
}

/** Download response - first message is metadata, followed by chunks */
export interface DownloadChunkResponse {
  trace_id: string;
  /** First message: object metadata */
  metadata?:
    | DownloadMetadata
    | undefined;
  /** Subsequent messages: file chunks */
  chunk?: Uint8Array | undefined;
}

export interface DownloadMetadata {
  bucket: string;
  key: string;
  content_type: string;
  content_length: number;
  etag: string;
  last_modified: string;
}

export interface GetUploadUrlRequest {
  bucket: string;
  key: string;
  content_type?:
    | string
    | undefined;
  /** Default: 3600 (1 hour) */
  expires_in_seconds?: number | undefined;
}

export interface GetDownloadUrlRequest {
  bucket: string;
  key: string;
  /** Default: 3600 (1 hour) */
  expires_in_seconds?: number | undefined;
}

export interface DeleteObjectRequest {
  bucket: string;
  keys: string[];
}

export interface CopyObjectRequest {
  source_bucket: string;
  source_key: string;
  dest_bucket: string;
  dest_key: string;
}

export interface AbortUploadRequest {
  bucket: string;
  key: string;
  upload_id: string;
}

export interface ObjectInfo {
  key: string;
  size: number;
  last_modified: string;
  etag: string;
  storage_class: string;
}

export interface ObjectMetadata {
  content_length: number;
  content_type: string;
  etag: string;
  last_modified: string;
}

export interface UploadResult {
  bucket: string;
  key: string;
  etag: string;
  size: number;
}

export interface CopyResult {
  etag: string;
  last_modified: string;
}

export interface DeleteError {
  key: string;
  code: string;
  message: string;
}

export interface PreSignedUrl {
  url: string;
  /** GET or PUT */
  method: string;
  /** Unix timestamp */
  expires_at: number;
  expires_in_seconds: number;
}

function createBaseListObjectsResponse(): ListObjectsResponse {
  return { trace_id: "", data: [], next_continuation_token: undefined, is_truncated: false };
}

export const ListObjectsResponse: MessageFns<ListObjectsResponse> = {
  encode(message: ListObjectsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    for (const v of message.data) {
      ObjectInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.next_continuation_token !== undefined) {
      writer.uint32(26).string(message.next_continuation_token);
    }
    if (message.is_truncated !== false) {
      writer.uint32(32).bool(message.is_truncated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListObjectsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListObjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(ObjectInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.next_continuation_token = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.is_truncated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListObjectsResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => ObjectInfo.fromJSON(e)) : [],
      next_continuation_token: isSet(object.nextContinuationToken)
        ? globalThis.String(object.nextContinuationToken)
        : isSet(object.next_continuation_token)
        ? globalThis.String(object.next_continuation_token)
        : undefined,
      is_truncated: isSet(object.isTruncated)
        ? globalThis.Boolean(object.isTruncated)
        : isSet(object.is_truncated)
        ? globalThis.Boolean(object.is_truncated)
        : false,
    };
  },

  toJSON(message: ListObjectsResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => ObjectInfo.toJSON(e));
    }
    if (message.next_continuation_token !== undefined) {
      obj.nextContinuationToken = message.next_continuation_token;
    }
    if (message.is_truncated !== false) {
      obj.isTruncated = message.is_truncated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListObjectsResponse>, I>>(base?: I): ListObjectsResponse {
    return ListObjectsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListObjectsResponse>, I>>(object: I): ListObjectsResponse {
    const message = createBaseListObjectsResponse();
    message.trace_id = object.trace_id ?? "";
    message.data = object.data?.map((e) => ObjectInfo.fromPartial(e)) || [];
    message.next_continuation_token = object.next_continuation_token ?? undefined;
    message.is_truncated = object.is_truncated ?? false;
    return message;
  },
};

function createBaseObjectMetadataResponse(): ObjectMetadataResponse {
  return { trace_id: "", data: undefined };
}

export const ObjectMetadataResponse: MessageFns<ObjectMetadataResponse> = {
  encode(message: ObjectMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.data !== undefined) {
      ObjectMetadata.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = ObjectMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectMetadataResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      data: isSet(object.data) ? ObjectMetadata.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: ObjectMetadataResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.data !== undefined) {
      obj.data = ObjectMetadata.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ObjectMetadataResponse>, I>>(base?: I): ObjectMetadataResponse {
    return ObjectMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ObjectMetadataResponse>, I>>(object: I): ObjectMetadataResponse {
    const message = createBaseObjectMetadataResponse();
    message.trace_id = object.trace_id ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? ObjectMetadata.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseUploadObjectResponse(): UploadObjectResponse {
  return { trace_id: "", data: undefined };
}

export const UploadObjectResponse: MessageFns<UploadObjectResponse> = {
  encode(message: UploadObjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.data !== undefined) {
      UploadResult.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadObjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadObjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = UploadResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadObjectResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      data: isSet(object.data) ? UploadResult.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: UploadObjectResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.data !== undefined) {
      obj.data = UploadResult.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadObjectResponse>, I>>(base?: I): UploadObjectResponse {
    return UploadObjectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadObjectResponse>, I>>(object: I): UploadObjectResponse {
    const message = createBaseUploadObjectResponse();
    message.trace_id = object.trace_id ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? UploadResult.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseDeleteObjectResponse(): DeleteObjectResponse {
  return { trace_id: "", deleted: [], errors: [] };
}

export const DeleteObjectResponse: MessageFns<DeleteObjectResponse> = {
  encode(message: DeleteObjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    for (const v of message.deleted) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.errors) {
      DeleteError.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteObjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteObjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deleted.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(DeleteError.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteObjectResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      deleted: globalThis.Array.isArray(object?.deleted) ? object.deleted.map((e: any) => globalThis.String(e)) : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => DeleteError.fromJSON(e)) : [],
    };
  },

  toJSON(message: DeleteObjectResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.deleted?.length) {
      obj.deleted = message.deleted;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => DeleteError.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteObjectResponse>, I>>(base?: I): DeleteObjectResponse {
    return DeleteObjectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteObjectResponse>, I>>(object: I): DeleteObjectResponse {
    const message = createBaseDeleteObjectResponse();
    message.trace_id = object.trace_id ?? "";
    message.deleted = object.deleted?.map((e) => e) || [];
    message.errors = object.errors?.map((e) => DeleteError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCopyObjectResponse(): CopyObjectResponse {
  return { trace_id: "", data: undefined };
}

export const CopyObjectResponse: MessageFns<CopyObjectResponse> = {
  encode(message: CopyObjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.data !== undefined) {
      CopyResult.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CopyObjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCopyObjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = CopyResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CopyObjectResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      data: isSet(object.data) ? CopyResult.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: CopyObjectResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.data !== undefined) {
      obj.data = CopyResult.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CopyObjectResponse>, I>>(base?: I): CopyObjectResponse {
    return CopyObjectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CopyObjectResponse>, I>>(object: I): CopyObjectResponse {
    const message = createBaseCopyObjectResponse();
    message.trace_id = object.trace_id ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? CopyResult.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseAbortUploadResponse(): AbortUploadResponse {
  return { trace_id: "", success: false, bucket: "", key: "", upload_id: "" };
}

export const AbortUploadResponse: MessageFns<AbortUploadResponse> = {
  encode(message: AbortUploadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.bucket !== "") {
      writer.uint32(26).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(34).string(message.key);
    }
    if (message.upload_id !== "") {
      writer.uint32(42).string(message.upload_id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AbortUploadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbortUploadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.upload_id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AbortUploadResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      upload_id: isSet(object.uploadId)
        ? globalThis.String(object.uploadId)
        : isSet(object.upload_id)
        ? globalThis.String(object.upload_id)
        : "",
    };
  },

  toJSON(message: AbortUploadResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.upload_id !== "") {
      obj.uploadId = message.upload_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AbortUploadResponse>, I>>(base?: I): AbortUploadResponse {
    return AbortUploadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AbortUploadResponse>, I>>(object: I): AbortUploadResponse {
    const message = createBaseAbortUploadResponse();
    message.trace_id = object.trace_id ?? "";
    message.success = object.success ?? false;
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    message.upload_id = object.upload_id ?? "";
    return message;
  },
};

function createBasePreSignedUrlResponse(): PreSignedUrlResponse {
  return { trace_id: "", data: undefined };
}

export const PreSignedUrlResponse: MessageFns<PreSignedUrlResponse> = {
  encode(message: PreSignedUrlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.data !== undefined) {
      PreSignedUrl.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreSignedUrlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreSignedUrlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = PreSignedUrl.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreSignedUrlResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      data: isSet(object.data) ? PreSignedUrl.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: PreSignedUrlResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.data !== undefined) {
      obj.data = PreSignedUrl.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreSignedUrlResponse>, I>>(base?: I): PreSignedUrlResponse {
    return PreSignedUrlResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreSignedUrlResponse>, I>>(object: I): PreSignedUrlResponse {
    const message = createBasePreSignedUrlResponse();
    message.trace_id = object.trace_id ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? PreSignedUrl.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseListObjectsRequest(): ListObjectsRequest {
  return { bucket: "", prefix: undefined, continuation_token: undefined, max_keys: undefined };
}

export const ListObjectsRequest: MessageFns<ListObjectsRequest> = {
  encode(message: ListObjectsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.prefix !== undefined) {
      writer.uint32(18).string(message.prefix);
    }
    if (message.continuation_token !== undefined) {
      writer.uint32(26).string(message.continuation_token);
    }
    if (message.max_keys !== undefined) {
      writer.uint32(32).int32(message.max_keys);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListObjectsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListObjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.continuation_token = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.max_keys = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListObjectsRequest {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      continuation_token: isSet(object.continuationToken)
        ? globalThis.String(object.continuationToken)
        : isSet(object.continuation_token)
        ? globalThis.String(object.continuation_token)
        : undefined,
      max_keys: isSet(object.maxKeys)
        ? globalThis.Number(object.maxKeys)
        : isSet(object.max_keys)
        ? globalThis.Number(object.max_keys)
        : undefined,
    };
  },

  toJSON(message: ListObjectsRequest): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.continuation_token !== undefined) {
      obj.continuationToken = message.continuation_token;
    }
    if (message.max_keys !== undefined) {
      obj.maxKeys = Math.round(message.max_keys);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListObjectsRequest>, I>>(base?: I): ListObjectsRequest {
    return ListObjectsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListObjectsRequest>, I>>(object: I): ListObjectsRequest {
    const message = createBaseListObjectsRequest();
    message.bucket = object.bucket ?? "";
    message.prefix = object.prefix ?? undefined;
    message.continuation_token = object.continuation_token ?? undefined;
    message.max_keys = object.max_keys ?? undefined;
    return message;
  },
};

function createBaseGetObjectMetadataRequest(): GetObjectMetadataRequest {
  return { bucket: "", key: "" };
}

export const GetObjectMetadataRequest: MessageFns<GetObjectMetadataRequest> = {
  encode(message: GetObjectMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetObjectMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetObjectMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetObjectMetadataRequest {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: GetObjectMetadataRequest): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetObjectMetadataRequest>, I>>(base?: I): GetObjectMetadataRequest {
    return GetObjectMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetObjectMetadataRequest>, I>>(object: I): GetObjectMetadataRequest {
    const message = createBaseGetObjectMetadataRequest();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseUploadChunkRequest(): UploadChunkRequest {
  return { metadata: undefined, chunk: undefined };
}

export const UploadChunkRequest: MessageFns<UploadChunkRequest> = {
  encode(message: UploadChunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      UploadMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.chunk !== undefined) {
      writer.uint32(18).bytes(message.chunk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadChunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadChunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = UploadMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chunk = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadChunkRequest {
    return {
      metadata: isSet(object.metadata) ? UploadMetadata.fromJSON(object.metadata) : undefined,
      chunk: isSet(object.chunk) ? bytesFromBase64(object.chunk) : undefined,
    };
  },

  toJSON(message: UploadChunkRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = UploadMetadata.toJSON(message.metadata);
    }
    if (message.chunk !== undefined) {
      obj.chunk = base64FromBytes(message.chunk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadChunkRequest>, I>>(base?: I): UploadChunkRequest {
    return UploadChunkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadChunkRequest>, I>>(object: I): UploadChunkRequest {
    const message = createBaseUploadChunkRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? UploadMetadata.fromPartial(object.metadata)
      : undefined;
    message.chunk = object.chunk ?? undefined;
    return message;
  },
};

function createBaseUploadMetadata(): UploadMetadata {
  return { bucket: "", key: "", content_type: "", content_length: 0 };
}

export const UploadMetadata: MessageFns<UploadMetadata> = {
  encode(message: UploadMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.content_type !== "") {
      writer.uint32(26).string(message.content_type);
    }
    if (message.content_length !== 0) {
      writer.uint32(32).int64(message.content_length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content_type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.content_length = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadMetadata {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      content_type: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : isSet(object.content_type)
        ? globalThis.String(object.content_type)
        : "",
      content_length: isSet(object.contentLength)
        ? globalThis.Number(object.contentLength)
        : isSet(object.content_length)
        ? globalThis.Number(object.content_length)
        : 0,
    };
  },

  toJSON(message: UploadMetadata): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.content_type !== "") {
      obj.contentType = message.content_type;
    }
    if (message.content_length !== 0) {
      obj.contentLength = Math.round(message.content_length);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadMetadata>, I>>(base?: I): UploadMetadata {
    return UploadMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadMetadata>, I>>(object: I): UploadMetadata {
    const message = createBaseUploadMetadata();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    message.content_type = object.content_type ?? "";
    message.content_length = object.content_length ?? 0;
    return message;
  },
};

function createBaseUploadChunkResponse(): UploadChunkResponse {
  return { trace_id: "", initiated: undefined, progress: undefined, result: undefined };
}

export const UploadChunkResponse: MessageFns<UploadChunkResponse> = {
  encode(message: UploadChunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.initiated !== undefined) {
      UploadInitiated.encode(message.initiated, writer.uint32(18).fork()).join();
    }
    if (message.progress !== undefined) {
      UploadProgress.encode(message.progress, writer.uint32(26).fork()).join();
    }
    if (message.result !== undefined) {
      UploadResult.encode(message.result, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadChunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadChunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.initiated = UploadInitiated.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.progress = UploadProgress.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.result = UploadResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadChunkResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      initiated: isSet(object.initiated) ? UploadInitiated.fromJSON(object.initiated) : undefined,
      progress: isSet(object.progress) ? UploadProgress.fromJSON(object.progress) : undefined,
      result: isSet(object.result) ? UploadResult.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: UploadChunkResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.initiated !== undefined) {
      obj.initiated = UploadInitiated.toJSON(message.initiated);
    }
    if (message.progress !== undefined) {
      obj.progress = UploadProgress.toJSON(message.progress);
    }
    if (message.result !== undefined) {
      obj.result = UploadResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadChunkResponse>, I>>(base?: I): UploadChunkResponse {
    return UploadChunkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadChunkResponse>, I>>(object: I): UploadChunkResponse {
    const message = createBaseUploadChunkResponse();
    message.trace_id = object.trace_id ?? "";
    message.initiated = (object.initiated !== undefined && object.initiated !== null)
      ? UploadInitiated.fromPartial(object.initiated)
      : undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? UploadProgress.fromPartial(object.progress)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? UploadResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseUploadInitiated(): UploadInitiated {
  return { upload_id: "", bucket: "", key: "" };
}

export const UploadInitiated: MessageFns<UploadInitiated> = {
  encode(message: UploadInitiated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.upload_id !== "") {
      writer.uint32(10).string(message.upload_id);
    }
    if (message.bucket !== "") {
      writer.uint32(18).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadInitiated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadInitiated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.upload_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadInitiated {
    return {
      upload_id: isSet(object.uploadId)
        ? globalThis.String(object.uploadId)
        : isSet(object.upload_id)
        ? globalThis.String(object.upload_id)
        : "",
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: UploadInitiated): unknown {
    const obj: any = {};
    if (message.upload_id !== "") {
      obj.uploadId = message.upload_id;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadInitiated>, I>>(base?: I): UploadInitiated {
    return UploadInitiated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadInitiated>, I>>(object: I): UploadInitiated {
    const message = createBaseUploadInitiated();
    message.upload_id = object.upload_id ?? "";
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseUploadProgress(): UploadProgress {
  return { part_number: 0, bytes_uploaded: 0, total_bytes: 0 };
}

export const UploadProgress: MessageFns<UploadProgress> = {
  encode(message: UploadProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.part_number !== 0) {
      writer.uint32(8).int32(message.part_number);
    }
    if (message.bytes_uploaded !== 0) {
      writer.uint32(16).int64(message.bytes_uploaded);
    }
    if (message.total_bytes !== 0) {
      writer.uint32(24).int64(message.total_bytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.part_number = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytes_uploaded = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.total_bytes = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadProgress {
    return {
      part_number: isSet(object.partNumber)
        ? globalThis.Number(object.partNumber)
        : isSet(object.part_number)
        ? globalThis.Number(object.part_number)
        : 0,
      bytes_uploaded: isSet(object.bytesUploaded)
        ? globalThis.Number(object.bytesUploaded)
        : isSet(object.bytes_uploaded)
        ? globalThis.Number(object.bytes_uploaded)
        : 0,
      total_bytes: isSet(object.totalBytes)
        ? globalThis.Number(object.totalBytes)
        : isSet(object.total_bytes)
        ? globalThis.Number(object.total_bytes)
        : 0,
    };
  },

  toJSON(message: UploadProgress): unknown {
    const obj: any = {};
    if (message.part_number !== 0) {
      obj.partNumber = Math.round(message.part_number);
    }
    if (message.bytes_uploaded !== 0) {
      obj.bytesUploaded = Math.round(message.bytes_uploaded);
    }
    if (message.total_bytes !== 0) {
      obj.totalBytes = Math.round(message.total_bytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadProgress>, I>>(base?: I): UploadProgress {
    return UploadProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadProgress>, I>>(object: I): UploadProgress {
    const message = createBaseUploadProgress();
    message.part_number = object.part_number ?? 0;
    message.bytes_uploaded = object.bytes_uploaded ?? 0;
    message.total_bytes = object.total_bytes ?? 0;
    return message;
  },
};

function createBaseDownloadObjectRequest(): DownloadObjectRequest {
  return { bucket: "", key: "" };
}

export const DownloadObjectRequest: MessageFns<DownloadObjectRequest> = {
  encode(message: DownloadObjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DownloadObjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadObjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadObjectRequest {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: DownloadObjectRequest): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadObjectRequest>, I>>(base?: I): DownloadObjectRequest {
    return DownloadObjectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadObjectRequest>, I>>(object: I): DownloadObjectRequest {
    const message = createBaseDownloadObjectRequest();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDownloadChunkResponse(): DownloadChunkResponse {
  return { trace_id: "", metadata: undefined, chunk: undefined };
}

export const DownloadChunkResponse: MessageFns<DownloadChunkResponse> = {
  encode(message: DownloadChunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.metadata !== undefined) {
      DownloadMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.chunk !== undefined) {
      writer.uint32(26).bytes(message.chunk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DownloadChunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadChunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = DownloadMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chunk = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadChunkResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      metadata: isSet(object.metadata) ? DownloadMetadata.fromJSON(object.metadata) : undefined,
      chunk: isSet(object.chunk) ? bytesFromBase64(object.chunk) : undefined,
    };
  },

  toJSON(message: DownloadChunkResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.metadata !== undefined) {
      obj.metadata = DownloadMetadata.toJSON(message.metadata);
    }
    if (message.chunk !== undefined) {
      obj.chunk = base64FromBytes(message.chunk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadChunkResponse>, I>>(base?: I): DownloadChunkResponse {
    return DownloadChunkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadChunkResponse>, I>>(object: I): DownloadChunkResponse {
    const message = createBaseDownloadChunkResponse();
    message.trace_id = object.trace_id ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? DownloadMetadata.fromPartial(object.metadata)
      : undefined;
    message.chunk = object.chunk ?? undefined;
    return message;
  },
};

function createBaseDownloadMetadata(): DownloadMetadata {
  return { bucket: "", key: "", content_type: "", content_length: 0, etag: "", last_modified: "" };
}

export const DownloadMetadata: MessageFns<DownloadMetadata> = {
  encode(message: DownloadMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.content_type !== "") {
      writer.uint32(26).string(message.content_type);
    }
    if (message.content_length !== 0) {
      writer.uint32(32).int64(message.content_length);
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    if (message.last_modified !== "") {
      writer.uint32(50).string(message.last_modified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DownloadMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content_type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.content_length = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.last_modified = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadMetadata {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      content_type: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : isSet(object.content_type)
        ? globalThis.String(object.content_type)
        : "",
      content_length: isSet(object.contentLength)
        ? globalThis.Number(object.contentLength)
        : isSet(object.content_length)
        ? globalThis.Number(object.content_length)
        : 0,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      last_modified: isSet(object.lastModified)
        ? globalThis.String(object.lastModified)
        : isSet(object.last_modified)
        ? globalThis.String(object.last_modified)
        : "",
    };
  },

  toJSON(message: DownloadMetadata): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.content_type !== "") {
      obj.contentType = message.content_type;
    }
    if (message.content_length !== 0) {
      obj.contentLength = Math.round(message.content_length);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.last_modified !== "") {
      obj.lastModified = message.last_modified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadMetadata>, I>>(base?: I): DownloadMetadata {
    return DownloadMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadMetadata>, I>>(object: I): DownloadMetadata {
    const message = createBaseDownloadMetadata();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    message.content_type = object.content_type ?? "";
    message.content_length = object.content_length ?? 0;
    message.etag = object.etag ?? "";
    message.last_modified = object.last_modified ?? "";
    return message;
  },
};

function createBaseGetUploadUrlRequest(): GetUploadUrlRequest {
  return { bucket: "", key: "", content_type: undefined, expires_in_seconds: undefined };
}

export const GetUploadUrlRequest: MessageFns<GetUploadUrlRequest> = {
  encode(message: GetUploadUrlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.content_type !== undefined) {
      writer.uint32(26).string(message.content_type);
    }
    if (message.expires_in_seconds !== undefined) {
      writer.uint32(32).int32(message.expires_in_seconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUploadUrlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUploadUrlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content_type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expires_in_seconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUploadUrlRequest {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      content_type: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : isSet(object.content_type)
        ? globalThis.String(object.content_type)
        : undefined,
      expires_in_seconds: isSet(object.expiresInSeconds)
        ? globalThis.Number(object.expiresInSeconds)
        : isSet(object.expires_in_seconds)
        ? globalThis.Number(object.expires_in_seconds)
        : undefined,
    };
  },

  toJSON(message: GetUploadUrlRequest): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.content_type !== undefined) {
      obj.contentType = message.content_type;
    }
    if (message.expires_in_seconds !== undefined) {
      obj.expiresInSeconds = Math.round(message.expires_in_seconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUploadUrlRequest>, I>>(base?: I): GetUploadUrlRequest {
    return GetUploadUrlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUploadUrlRequest>, I>>(object: I): GetUploadUrlRequest {
    const message = createBaseGetUploadUrlRequest();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    message.content_type = object.content_type ?? undefined;
    message.expires_in_seconds = object.expires_in_seconds ?? undefined;
    return message;
  },
};

function createBaseGetDownloadUrlRequest(): GetDownloadUrlRequest {
  return { bucket: "", key: "", expires_in_seconds: undefined };
}

export const GetDownloadUrlRequest: MessageFns<GetDownloadUrlRequest> = {
  encode(message: GetDownloadUrlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.expires_in_seconds !== undefined) {
      writer.uint32(24).int32(message.expires_in_seconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDownloadUrlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDownloadUrlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expires_in_seconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDownloadUrlRequest {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      expires_in_seconds: isSet(object.expiresInSeconds)
        ? globalThis.Number(object.expiresInSeconds)
        : isSet(object.expires_in_seconds)
        ? globalThis.Number(object.expires_in_seconds)
        : undefined,
    };
  },

  toJSON(message: GetDownloadUrlRequest): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.expires_in_seconds !== undefined) {
      obj.expiresInSeconds = Math.round(message.expires_in_seconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDownloadUrlRequest>, I>>(base?: I): GetDownloadUrlRequest {
    return GetDownloadUrlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDownloadUrlRequest>, I>>(object: I): GetDownloadUrlRequest {
    const message = createBaseGetDownloadUrlRequest();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    message.expires_in_seconds = object.expires_in_seconds ?? undefined;
    return message;
  },
};

function createBaseDeleteObjectRequest(): DeleteObjectRequest {
  return { bucket: "", keys: [] };
}

export const DeleteObjectRequest: MessageFns<DeleteObjectRequest> = {
  encode(message: DeleteObjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    for (const v of message.keys) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteObjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteObjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keys.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteObjectRequest {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteObjectRequest): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteObjectRequest>, I>>(base?: I): DeleteObjectRequest {
    return DeleteObjectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteObjectRequest>, I>>(object: I): DeleteObjectRequest {
    const message = createBaseDeleteObjectRequest();
    message.bucket = object.bucket ?? "";
    message.keys = object.keys?.map((e) => e) || [];
    return message;
  },
};

function createBaseCopyObjectRequest(): CopyObjectRequest {
  return { source_bucket: "", source_key: "", dest_bucket: "", dest_key: "" };
}

export const CopyObjectRequest: MessageFns<CopyObjectRequest> = {
  encode(message: CopyObjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source_bucket !== "") {
      writer.uint32(10).string(message.source_bucket);
    }
    if (message.source_key !== "") {
      writer.uint32(18).string(message.source_key);
    }
    if (message.dest_bucket !== "") {
      writer.uint32(26).string(message.dest_bucket);
    }
    if (message.dest_key !== "") {
      writer.uint32(34).string(message.dest_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CopyObjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCopyObjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source_bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source_key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dest_bucket = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dest_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CopyObjectRequest {
    return {
      source_bucket: isSet(object.sourceBucket)
        ? globalThis.String(object.sourceBucket)
        : isSet(object.source_bucket)
        ? globalThis.String(object.source_bucket)
        : "",
      source_key: isSet(object.sourceKey)
        ? globalThis.String(object.sourceKey)
        : isSet(object.source_key)
        ? globalThis.String(object.source_key)
        : "",
      dest_bucket: isSet(object.destBucket)
        ? globalThis.String(object.destBucket)
        : isSet(object.dest_bucket)
        ? globalThis.String(object.dest_bucket)
        : "",
      dest_key: isSet(object.destKey)
        ? globalThis.String(object.destKey)
        : isSet(object.dest_key)
        ? globalThis.String(object.dest_key)
        : "",
    };
  },

  toJSON(message: CopyObjectRequest): unknown {
    const obj: any = {};
    if (message.source_bucket !== "") {
      obj.sourceBucket = message.source_bucket;
    }
    if (message.source_key !== "") {
      obj.sourceKey = message.source_key;
    }
    if (message.dest_bucket !== "") {
      obj.destBucket = message.dest_bucket;
    }
    if (message.dest_key !== "") {
      obj.destKey = message.dest_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CopyObjectRequest>, I>>(base?: I): CopyObjectRequest {
    return CopyObjectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CopyObjectRequest>, I>>(object: I): CopyObjectRequest {
    const message = createBaseCopyObjectRequest();
    message.source_bucket = object.source_bucket ?? "";
    message.source_key = object.source_key ?? "";
    message.dest_bucket = object.dest_bucket ?? "";
    message.dest_key = object.dest_key ?? "";
    return message;
  },
};

function createBaseAbortUploadRequest(): AbortUploadRequest {
  return { bucket: "", key: "", upload_id: "" };
}

export const AbortUploadRequest: MessageFns<AbortUploadRequest> = {
  encode(message: AbortUploadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.upload_id !== "") {
      writer.uint32(26).string(message.upload_id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AbortUploadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbortUploadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upload_id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AbortUploadRequest {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      upload_id: isSet(object.uploadId)
        ? globalThis.String(object.uploadId)
        : isSet(object.upload_id)
        ? globalThis.String(object.upload_id)
        : "",
    };
  },

  toJSON(message: AbortUploadRequest): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.upload_id !== "") {
      obj.uploadId = message.upload_id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AbortUploadRequest>, I>>(base?: I): AbortUploadRequest {
    return AbortUploadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AbortUploadRequest>, I>>(object: I): AbortUploadRequest {
    const message = createBaseAbortUploadRequest();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    message.upload_id = object.upload_id ?? "";
    return message;
  },
};

function createBaseObjectInfo(): ObjectInfo {
  return { key: "", size: 0, last_modified: "", etag: "", storage_class: "" };
}

export const ObjectInfo: MessageFns<ObjectInfo> = {
  encode(message: ObjectInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.size !== 0) {
      writer.uint32(16).int64(message.size);
    }
    if (message.last_modified !== "") {
      writer.uint32(26).string(message.last_modified);
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    if (message.storage_class !== "") {
      writer.uint32(42).string(message.storage_class);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.last_modified = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.storage_class = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectInfo {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      last_modified: isSet(object.lastModified)
        ? globalThis.String(object.lastModified)
        : isSet(object.last_modified)
        ? globalThis.String(object.last_modified)
        : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      storage_class: isSet(object.storageClass)
        ? globalThis.String(object.storageClass)
        : isSet(object.storage_class)
        ? globalThis.String(object.storage_class)
        : "",
    };
  },

  toJSON(message: ObjectInfo): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.last_modified !== "") {
      obj.lastModified = message.last_modified;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.storage_class !== "") {
      obj.storageClass = message.storage_class;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ObjectInfo>, I>>(base?: I): ObjectInfo {
    return ObjectInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ObjectInfo>, I>>(object: I): ObjectInfo {
    const message = createBaseObjectInfo();
    message.key = object.key ?? "";
    message.size = object.size ?? 0;
    message.last_modified = object.last_modified ?? "";
    message.etag = object.etag ?? "";
    message.storage_class = object.storage_class ?? "";
    return message;
  },
};

function createBaseObjectMetadata(): ObjectMetadata {
  return { content_length: 0, content_type: "", etag: "", last_modified: "" };
}

export const ObjectMetadata: MessageFns<ObjectMetadata> = {
  encode(message: ObjectMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content_length !== 0) {
      writer.uint32(8).int64(message.content_length);
    }
    if (message.content_type !== "") {
      writer.uint32(18).string(message.content_type);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    if (message.last_modified !== "") {
      writer.uint32(34).string(message.last_modified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.content_length = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content_type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.last_modified = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectMetadata {
    return {
      content_length: isSet(object.contentLength)
        ? globalThis.Number(object.contentLength)
        : isSet(object.content_length)
        ? globalThis.Number(object.content_length)
        : 0,
      content_type: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : isSet(object.content_type)
        ? globalThis.String(object.content_type)
        : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      last_modified: isSet(object.lastModified)
        ? globalThis.String(object.lastModified)
        : isSet(object.last_modified)
        ? globalThis.String(object.last_modified)
        : "",
    };
  },

  toJSON(message: ObjectMetadata): unknown {
    const obj: any = {};
    if (message.content_length !== 0) {
      obj.contentLength = Math.round(message.content_length);
    }
    if (message.content_type !== "") {
      obj.contentType = message.content_type;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.last_modified !== "") {
      obj.lastModified = message.last_modified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ObjectMetadata>, I>>(base?: I): ObjectMetadata {
    return ObjectMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ObjectMetadata>, I>>(object: I): ObjectMetadata {
    const message = createBaseObjectMetadata();
    message.content_length = object.content_length ?? 0;
    message.content_type = object.content_type ?? "";
    message.etag = object.etag ?? "";
    message.last_modified = object.last_modified ?? "";
    return message;
  },
};

function createBaseUploadResult(): UploadResult {
  return { bucket: "", key: "", etag: "", size: 0 };
}

export const UploadResult: MessageFns<UploadResult> = {
  encode(message: UploadResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    if (message.size !== 0) {
      writer.uint32(32).int64(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadResult {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: UploadResult): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadResult>, I>>(base?: I): UploadResult {
    return UploadResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadResult>, I>>(object: I): UploadResult {
    const message = createBaseUploadResult();
    message.bucket = object.bucket ?? "";
    message.key = object.key ?? "";
    message.etag = object.etag ?? "";
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseCopyResult(): CopyResult {
  return { etag: "", last_modified: "" };
}

export const CopyResult: MessageFns<CopyResult> = {
  encode(message: CopyResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.etag !== "") {
      writer.uint32(10).string(message.etag);
    }
    if (message.last_modified !== "") {
      writer.uint32(18).string(message.last_modified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CopyResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCopyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.last_modified = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CopyResult {
    return {
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      last_modified: isSet(object.lastModified)
        ? globalThis.String(object.lastModified)
        : isSet(object.last_modified)
        ? globalThis.String(object.last_modified)
        : "",
    };
  },

  toJSON(message: CopyResult): unknown {
    const obj: any = {};
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.last_modified !== "") {
      obj.lastModified = message.last_modified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CopyResult>, I>>(base?: I): CopyResult {
    return CopyResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CopyResult>, I>>(object: I): CopyResult {
    const message = createBaseCopyResult();
    message.etag = object.etag ?? "";
    message.last_modified = object.last_modified ?? "";
    return message;
  },
};

function createBaseDeleteError(): DeleteError {
  return { key: "", code: "", message: "" };
}

export const DeleteError: MessageFns<DeleteError> = {
  encode(message: DeleteError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteError {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteError): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteError>, I>>(base?: I): DeleteError {
    return DeleteError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteError>, I>>(object: I): DeleteError {
    const message = createBaseDeleteError();
    message.key = object.key ?? "";
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePreSignedUrl(): PreSignedUrl {
  return { url: "", method: "", expires_at: 0, expires_in_seconds: 0 };
}

export const PreSignedUrl: MessageFns<PreSignedUrl> = {
  encode(message: PreSignedUrl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.method !== "") {
      writer.uint32(18).string(message.method);
    }
    if (message.expires_at !== 0) {
      writer.uint32(24).int64(message.expires_at);
    }
    if (message.expires_in_seconds !== 0) {
      writer.uint32(32).int32(message.expires_in_seconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreSignedUrl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreSignedUrl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expires_at = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expires_in_seconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreSignedUrl {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      expires_at: isSet(object.expiresAt)
        ? globalThis.Number(object.expiresAt)
        : isSet(object.expires_at)
        ? globalThis.Number(object.expires_at)
        : 0,
      expires_in_seconds: isSet(object.expiresInSeconds)
        ? globalThis.Number(object.expiresInSeconds)
        : isSet(object.expires_in_seconds)
        ? globalThis.Number(object.expires_in_seconds)
        : 0,
    };
  },

  toJSON(message: PreSignedUrl): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.expires_at !== 0) {
      obj.expiresAt = Math.round(message.expires_at);
    }
    if (message.expires_in_seconds !== 0) {
      obj.expiresInSeconds = Math.round(message.expires_in_seconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreSignedUrl>, I>>(base?: I): PreSignedUrl {
    return PreSignedUrl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreSignedUrl>, I>>(object: I): PreSignedUrl {
    const message = createBasePreSignedUrl();
    message.url = object.url ?? "";
    message.method = object.method ?? "";
    message.expires_at = object.expires_at ?? 0;
    message.expires_in_seconds = object.expires_in_seconds ?? 0;
    return message;
  },
};

/**
 * Object Service - gRPC API for S3 object management
 * 
 * 1. gRPC Streaming -  gRPC /
 * 2. PreSigned URL -  URL  S3 
 */
export interface ObjectService {
  /** List objects in a bucket with pagination */
  ListObjects(request: ListObjectsRequest): Promise<ListObjectsResponse>;
  /** Get object metadata (HEAD) */
  GetObjectMetadata(request: GetObjectMetadataRequest): Promise<ObjectMetadataResponse>;
  /**
   * Upload object using bidirectional streaming
   * Client sends metadata first, server responds with upload_id, then client sends chunks
   * Server sends progress updates and final result
   */
  UploadObject(request: Observable<UploadChunkRequest>): Observable<UploadChunkResponse>;
  /**
   * Download object using server streaming
   * Server sends metadata first, then file chunks
   */
  DownloadObject(request: DownloadObjectRequest): Observable<DownloadChunkResponse>;
  /** Get presigned URL for upload (PUT) */
  GetUploadUrl(request: GetUploadUrlRequest): Promise<PreSignedUrlResponse>;
  /** Get presigned URL for download (GET) */
  GetDownloadUrl(request: GetDownloadUrlRequest): Promise<PreSignedUrlResponse>;
  /** Delete objects (supports single or batch delete) */
  DeleteObject(request: DeleteObjectRequest): Promise<DeleteObjectResponse>;
  /** Copy an object */
  CopyObject(request: CopyObjectRequest): Promise<CopyObjectResponse>;
  /** Abort a multipart upload */
  AbortUpload(request: AbortUploadRequest): Promise<AbortUploadResponse>;
}

export const ObjectServiceServiceName = "object.ObjectService";
export class ObjectServiceClientImpl implements ObjectService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ObjectServiceServiceName;
    this.rpc = rpc;
    this.ListObjects = this.ListObjects.bind(this);
    this.GetObjectMetadata = this.GetObjectMetadata.bind(this);
    this.UploadObject = this.UploadObject.bind(this);
    this.DownloadObject = this.DownloadObject.bind(this);
    this.GetUploadUrl = this.GetUploadUrl.bind(this);
    this.GetDownloadUrl = this.GetDownloadUrl.bind(this);
    this.DeleteObject = this.DeleteObject.bind(this);
    this.CopyObject = this.CopyObject.bind(this);
    this.AbortUpload = this.AbortUpload.bind(this);
  }
  ListObjects(request: ListObjectsRequest): Promise<ListObjectsResponse> {
    const data = ListObjectsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListObjects", data);
    return promise.then((data) => ListObjectsResponse.decode(new BinaryReader(data)));
  }

  GetObjectMetadata(request: GetObjectMetadataRequest): Promise<ObjectMetadataResponse> {
    const data = GetObjectMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetObjectMetadata", data);
    return promise.then((data) => ObjectMetadataResponse.decode(new BinaryReader(data)));
  }

  UploadObject(request: Observable<UploadChunkRequest>): Observable<UploadChunkResponse> {
    const data = request.pipe(map((request) => UploadChunkRequest.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "UploadObject", data);
    return result.pipe(map((data) => UploadChunkResponse.decode(new BinaryReader(data))));
  }

  DownloadObject(request: DownloadObjectRequest): Observable<DownloadChunkResponse> {
    const data = DownloadObjectRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "DownloadObject", data);
    return result.pipe(map((data) => DownloadChunkResponse.decode(new BinaryReader(data))));
  }

  GetUploadUrl(request: GetUploadUrlRequest): Promise<PreSignedUrlResponse> {
    const data = GetUploadUrlRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUploadUrl", data);
    return promise.then((data) => PreSignedUrlResponse.decode(new BinaryReader(data)));
  }

  GetDownloadUrl(request: GetDownloadUrlRequest): Promise<PreSignedUrlResponse> {
    const data = GetDownloadUrlRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDownloadUrl", data);
    return promise.then((data) => PreSignedUrlResponse.decode(new BinaryReader(data)));
  }

  DeleteObject(request: DeleteObjectRequest): Promise<DeleteObjectResponse> {
    const data = DeleteObjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteObject", data);
    return promise.then((data) => DeleteObjectResponse.decode(new BinaryReader(data)));
  }

  CopyObject(request: CopyObjectRequest): Promise<CopyObjectResponse> {
    const data = CopyObjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CopyObject", data);
    return promise.then((data) => CopyObjectResponse.decode(new BinaryReader(data)));
  }

  AbortUpload(request: AbortUploadRequest): Promise<AbortUploadResponse> {
    const data = AbortUploadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AbortUpload", data);
    return promise.then((data) => AbortUploadResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
