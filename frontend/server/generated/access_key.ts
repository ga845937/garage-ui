// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v5.29.3
// source: access_key.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { DateRange, NullableString, Pagination } from "./utility";

export const protobufPackage = "access_key";

export interface ListKeysResponse {
  trace_id: string;
  data: KeyListItem[];
  total: number;
}

export interface KeyResponse {
  trace_id: string;
  data: Key | undefined;
}

export interface DeleteKeyResponse {
  trace_id: string;
  id: string[];
}

export interface ListKeysRequest {
  pagination: Pagination | undefined;
  name?: string | undefined;
  created?: DateRange | undefined;
  expiration?: DateRange | undefined;
}

export interface ReadKeyRequest {
  id: string;
}

export interface CreateKeyRequest {
  name: string;
  expiration?: string | undefined;
  allow_create_bucket?: boolean | undefined;
}

export interface UpdateKeyRequest {
  id: string;
  name?: string | undefined;
  expiration?: NullableString | undefined;
  allow_create_bucket?: boolean | undefined;
}

export interface DeleteKeyRequest {
  id: string[];
}

/** ============== Messages ============== */
export interface KeyPerm {
  create_bucket: boolean;
}

export interface KeyListItem {
  id: string;
  name: string;
  created: string;
  expiration?: string | undefined;
  secret_access_key: string;
}

export interface Key {
  id: string;
  name: string;
  permissions: KeyPermissions | undefined;
  buckets: KeyBucket[];
  secret_access_key: string;
  expiration?: string | undefined;
  created: string;
}

export interface KeyPermissions {
  create_bucket: boolean;
}

export interface KeyBucket {
  id: string;
  global_aliases: string[];
  local_aliases: string[];
  permissions: KeyBucketPermissions | undefined;
}

export interface KeyBucketPermissions {
  read: boolean;
  write: boolean;
  owner: boolean;
}

function createBaseListKeysResponse(): ListKeysResponse {
  return { trace_id: "", data: [], total: 0 };
}

export const ListKeysResponse: MessageFns<ListKeysResponse> = {
  encode(message: ListKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    for (const v of message.data) {
      KeyListItem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(24).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(KeyListItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => KeyListItem.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListKeysResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => KeyListItem.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKeysResponse>, I>>(base?: I): ListKeysResponse {
    return ListKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKeysResponse>, I>>(object: I): ListKeysResponse {
    const message = createBaseListKeysResponse();
    message.trace_id = object.trace_id ?? "";
    message.data = object.data?.map((e) => KeyListItem.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseKeyResponse(): KeyResponse {
  return { trace_id: "", data: undefined };
}

export const KeyResponse: MessageFns<KeyResponse> = {
  encode(message: KeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.data !== undefined) {
      Key.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Key.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      data: isSet(object.data) ? Key.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: KeyResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.data !== undefined) {
      obj.data = Key.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyResponse>, I>>(base?: I): KeyResponse {
    return KeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyResponse>, I>>(object: I): KeyResponse {
    const message = createBaseKeyResponse();
    message.trace_id = object.trace_id ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Key.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseDeleteKeyResponse(): DeleteKeyResponse {
  return { trace_id: "", id: [] };
}

export const DeleteKeyResponse: MessageFns<DeleteKeyResponse> = {
  encode(message: DeleteKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    for (const v of message.id) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteKeyResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DeleteKeyResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.id?.length) {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteKeyResponse>, I>>(base?: I): DeleteKeyResponse {
    return DeleteKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteKeyResponse>, I>>(object: I): DeleteKeyResponse {
    const message = createBaseDeleteKeyResponse();
    message.trace_id = object.trace_id ?? "";
    message.id = object.id?.map((e) => e) || [];
    return message;
  },
};

function createBaseListKeysRequest(): ListKeysRequest {
  return { pagination: undefined, name: undefined, created: undefined, expiration: undefined };
}

export const ListKeysRequest: MessageFns<ListKeysRequest> = {
  encode(message: ListKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.created !== undefined) {
      DateRange.encode(message.created, writer.uint32(26).fork()).join();
    }
    if (message.expiration !== undefined) {
      DateRange.encode(message.expiration, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.created = DateRange.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expiration = DateRange.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysRequest {
    return {
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      created: isSet(object.created) ? DateRange.fromJSON(object.created) : undefined,
      expiration: isSet(object.expiration) ? DateRange.fromJSON(object.expiration) : undefined,
    };
  },

  toJSON(message: ListKeysRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.created !== undefined) {
      obj.created = DateRange.toJSON(message.created);
    }
    if (message.expiration !== undefined) {
      obj.expiration = DateRange.toJSON(message.expiration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKeysRequest>, I>>(base?: I): ListKeysRequest {
    return ListKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKeysRequest>, I>>(object: I): ListKeysRequest {
    const message = createBaseListKeysRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    message.name = object.name ?? undefined;
    message.created = (object.created !== undefined && object.created !== null)
      ? DateRange.fromPartial(object.created)
      : undefined;
    message.expiration = (object.expiration !== undefined && object.expiration !== null)
      ? DateRange.fromPartial(object.expiration)
      : undefined;
    return message;
  },
};

function createBaseReadKeyRequest(): ReadKeyRequest {
  return { id: "" };
}

export const ReadKeyRequest: MessageFns<ReadKeyRequest> = {
  encode(message: ReadKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadKeyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: ReadKeyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadKeyRequest>, I>>(base?: I): ReadKeyRequest {
    return ReadKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadKeyRequest>, I>>(object: I): ReadKeyRequest {
    const message = createBaseReadKeyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateKeyRequest(): CreateKeyRequest {
  return { name: "", expiration: undefined, allow_create_bucket: undefined };
}

export const CreateKeyRequest: MessageFns<CreateKeyRequest> = {
  encode(message: CreateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.expiration !== undefined) {
      writer.uint32(18).string(message.expiration);
    }
    if (message.allow_create_bucket !== undefined) {
      writer.uint32(24).bool(message.allow_create_bucket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expiration = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allow_create_bucket = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateKeyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      expiration: isSet(object.expiration) ? globalThis.String(object.expiration) : undefined,
      allow_create_bucket: isSet(object.allowCreateBucket)
        ? globalThis.Boolean(object.allowCreateBucket)
        : isSet(object.allow_create_bucket)
        ? globalThis.Boolean(object.allow_create_bucket)
        : undefined,
    };
  },

  toJSON(message: CreateKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration;
    }
    if (message.allow_create_bucket !== undefined) {
      obj.allowCreateBucket = message.allow_create_bucket;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateKeyRequest>, I>>(base?: I): CreateKeyRequest {
    return CreateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateKeyRequest>, I>>(object: I): CreateKeyRequest {
    const message = createBaseCreateKeyRequest();
    message.name = object.name ?? "";
    message.expiration = object.expiration ?? undefined;
    message.allow_create_bucket = object.allow_create_bucket ?? undefined;
    return message;
  },
};

function createBaseUpdateKeyRequest(): UpdateKeyRequest {
  return { id: "", name: undefined, expiration: undefined, allow_create_bucket: undefined };
}

export const UpdateKeyRequest: MessageFns<UpdateKeyRequest> = {
  encode(message: UpdateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.expiration !== undefined) {
      NullableString.encode(message.expiration, writer.uint32(26).fork()).join();
    }
    if (message.allow_create_bucket !== undefined) {
      writer.uint32(32).bool(message.allow_create_bucket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expiration = NullableString.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allow_create_bucket = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateKeyRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      expiration: isSet(object.expiration) ? NullableString.fromJSON(object.expiration) : undefined,
      allow_create_bucket: isSet(object.allowCreateBucket)
        ? globalThis.Boolean(object.allowCreateBucket)
        : isSet(object.allow_create_bucket)
        ? globalThis.Boolean(object.allow_create_bucket)
        : undefined,
    };
  },

  toJSON(message: UpdateKeyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.expiration !== undefined) {
      obj.expiration = NullableString.toJSON(message.expiration);
    }
    if (message.allow_create_bucket !== undefined) {
      obj.allowCreateBucket = message.allow_create_bucket;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateKeyRequest>, I>>(base?: I): UpdateKeyRequest {
    return UpdateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateKeyRequest>, I>>(object: I): UpdateKeyRequest {
    const message = createBaseUpdateKeyRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.expiration = (object.expiration !== undefined && object.expiration !== null)
      ? NullableString.fromPartial(object.expiration)
      : undefined;
    message.allow_create_bucket = object.allow_create_bucket ?? undefined;
    return message;
  },
};

function createBaseDeleteKeyRequest(): DeleteKeyRequest {
  return { id: [] };
}

export const DeleteKeyRequest: MessageFns<DeleteKeyRequest> = {
  encode(message: DeleteKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.id) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteKeyRequest {
    return { id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: DeleteKeyRequest): unknown {
    const obj: any = {};
    if (message.id?.length) {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteKeyRequest>, I>>(base?: I): DeleteKeyRequest {
    return DeleteKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteKeyRequest>, I>>(object: I): DeleteKeyRequest {
    const message = createBaseDeleteKeyRequest();
    message.id = object.id?.map((e) => e) || [];
    return message;
  },
};

function createBaseKeyPerm(): KeyPerm {
  return { create_bucket: false };
}

export const KeyPerm: MessageFns<KeyPerm> = {
  encode(message: KeyPerm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.create_bucket !== false) {
      writer.uint32(8).bool(message.create_bucket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyPerm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyPerm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.create_bucket = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyPerm {
    return {
      create_bucket: isSet(object.createBucket)
        ? globalThis.Boolean(object.createBucket)
        : isSet(object.create_bucket)
        ? globalThis.Boolean(object.create_bucket)
        : false,
    };
  },

  toJSON(message: KeyPerm): unknown {
    const obj: any = {};
    if (message.create_bucket !== false) {
      obj.createBucket = message.create_bucket;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyPerm>, I>>(base?: I): KeyPerm {
    return KeyPerm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyPerm>, I>>(object: I): KeyPerm {
    const message = createBaseKeyPerm();
    message.create_bucket = object.create_bucket ?? false;
    return message;
  },
};

function createBaseKeyListItem(): KeyListItem {
  return { id: "", name: "", created: "", expiration: undefined, secret_access_key: "" };
}

export const KeyListItem: MessageFns<KeyListItem> = {
  encode(message: KeyListItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.created !== "") {
      writer.uint32(26).string(message.created);
    }
    if (message.expiration !== undefined) {
      writer.uint32(34).string(message.expiration);
    }
    if (message.secret_access_key !== "") {
      writer.uint32(42).string(message.secret_access_key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyListItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyListItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.created = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expiration = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.secret_access_key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyListItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      created: isSet(object.created) ? globalThis.String(object.created) : "",
      expiration: isSet(object.expiration) ? globalThis.String(object.expiration) : undefined,
      secret_access_key: isSet(object.secretAccessKey)
        ? globalThis.String(object.secretAccessKey)
        : isSet(object.secret_access_key)
        ? globalThis.String(object.secret_access_key)
        : "",
    };
  },

  toJSON(message: KeyListItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.created !== "") {
      obj.created = message.created;
    }
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration;
    }
    if (message.secret_access_key !== "") {
      obj.secretAccessKey = message.secret_access_key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyListItem>, I>>(base?: I): KeyListItem {
    return KeyListItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyListItem>, I>>(object: I): KeyListItem {
    const message = createBaseKeyListItem();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.created = object.created ?? "";
    message.expiration = object.expiration ?? undefined;
    message.secret_access_key = object.secret_access_key ?? "";
    return message;
  },
};

function createBaseKey(): Key {
  return {
    id: "",
    name: "",
    permissions: undefined,
    buckets: [],
    secret_access_key: "",
    expiration: undefined,
    created: "",
  };
}

export const Key: MessageFns<Key> = {
  encode(message: Key, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.permissions !== undefined) {
      KeyPermissions.encode(message.permissions, writer.uint32(26).fork()).join();
    }
    for (const v of message.buckets) {
      KeyBucket.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.secret_access_key !== "") {
      writer.uint32(42).string(message.secret_access_key);
    }
    if (message.expiration !== undefined) {
      writer.uint32(50).string(message.expiration);
    }
    if (message.created !== "") {
      writer.uint32(58).string(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Key {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.permissions = KeyPermissions.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.buckets.push(KeyBucket.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.secret_access_key = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiration = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.created = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Key {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      permissions: isSet(object.permissions) ? KeyPermissions.fromJSON(object.permissions) : undefined,
      buckets: globalThis.Array.isArray(object?.buckets) ? object.buckets.map((e: any) => KeyBucket.fromJSON(e)) : [],
      secret_access_key: isSet(object.secretAccessKey)
        ? globalThis.String(object.secretAccessKey)
        : isSet(object.secret_access_key)
        ? globalThis.String(object.secret_access_key)
        : "",
      expiration: isSet(object.expiration) ? globalThis.String(object.expiration) : undefined,
      created: isSet(object.created) ? globalThis.String(object.created) : "",
    };
  },

  toJSON(message: Key): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.permissions !== undefined) {
      obj.permissions = KeyPermissions.toJSON(message.permissions);
    }
    if (message.buckets?.length) {
      obj.buckets = message.buckets.map((e) => KeyBucket.toJSON(e));
    }
    if (message.secret_access_key !== "") {
      obj.secretAccessKey = message.secret_access_key;
    }
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration;
    }
    if (message.created !== "") {
      obj.created = message.created;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Key>, I>>(base?: I): Key {
    return Key.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Key>, I>>(object: I): Key {
    const message = createBaseKey();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.permissions = (object.permissions !== undefined && object.permissions !== null)
      ? KeyPermissions.fromPartial(object.permissions)
      : undefined;
    message.buckets = object.buckets?.map((e) => KeyBucket.fromPartial(e)) || [];
    message.secret_access_key = object.secret_access_key ?? "";
    message.expiration = object.expiration ?? undefined;
    message.created = object.created ?? "";
    return message;
  },
};

function createBaseKeyPermissions(): KeyPermissions {
  return { create_bucket: false };
}

export const KeyPermissions: MessageFns<KeyPermissions> = {
  encode(message: KeyPermissions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.create_bucket !== false) {
      writer.uint32(8).bool(message.create_bucket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyPermissions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyPermissions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.create_bucket = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyPermissions {
    return {
      create_bucket: isSet(object.createBucket)
        ? globalThis.Boolean(object.createBucket)
        : isSet(object.create_bucket)
        ? globalThis.Boolean(object.create_bucket)
        : false,
    };
  },

  toJSON(message: KeyPermissions): unknown {
    const obj: any = {};
    if (message.create_bucket !== false) {
      obj.createBucket = message.create_bucket;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyPermissions>, I>>(base?: I): KeyPermissions {
    return KeyPermissions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyPermissions>, I>>(object: I): KeyPermissions {
    const message = createBaseKeyPermissions();
    message.create_bucket = object.create_bucket ?? false;
    return message;
  },
};

function createBaseKeyBucket(): KeyBucket {
  return { id: "", global_aliases: [], local_aliases: [], permissions: undefined };
}

export const KeyBucket: MessageFns<KeyBucket> = {
  encode(message: KeyBucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.global_aliases) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.local_aliases) {
      writer.uint32(26).string(v!);
    }
    if (message.permissions !== undefined) {
      KeyBucketPermissions.encode(message.permissions, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyBucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.global_aliases.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.local_aliases.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.permissions = KeyBucketPermissions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyBucket {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      global_aliases: globalThis.Array.isArray(object?.globalAliases)
        ? object.globalAliases.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.global_aliases)
        ? object.global_aliases.map((e: any) => globalThis.String(e))
        : [],
      local_aliases: globalThis.Array.isArray(object?.localAliases)
        ? object.localAliases.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.local_aliases)
        ? object.local_aliases.map((e: any) => globalThis.String(e))
        : [],
      permissions: isSet(object.permissions) ? KeyBucketPermissions.fromJSON(object.permissions) : undefined,
    };
  },

  toJSON(message: KeyBucket): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.global_aliases?.length) {
      obj.globalAliases = message.global_aliases;
    }
    if (message.local_aliases?.length) {
      obj.localAliases = message.local_aliases;
    }
    if (message.permissions !== undefined) {
      obj.permissions = KeyBucketPermissions.toJSON(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyBucket>, I>>(base?: I): KeyBucket {
    return KeyBucket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyBucket>, I>>(object: I): KeyBucket {
    const message = createBaseKeyBucket();
    message.id = object.id ?? "";
    message.global_aliases = object.global_aliases?.map((e) => e) || [];
    message.local_aliases = object.local_aliases?.map((e) => e) || [];
    message.permissions = (object.permissions !== undefined && object.permissions !== null)
      ? KeyBucketPermissions.fromPartial(object.permissions)
      : undefined;
    return message;
  },
};

function createBaseKeyBucketPermissions(): KeyBucketPermissions {
  return { read: false, write: false, owner: false };
}

export const KeyBucketPermissions: MessageFns<KeyBucketPermissions> = {
  encode(message: KeyBucketPermissions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.read !== false) {
      writer.uint32(8).bool(message.read);
    }
    if (message.write !== false) {
      writer.uint32(16).bool(message.write);
    }
    if (message.owner !== false) {
      writer.uint32(24).bool(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyBucketPermissions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyBucketPermissions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.read = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.write = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.owner = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyBucketPermissions {
    return {
      read: isSet(object.read) ? globalThis.Boolean(object.read) : false,
      write: isSet(object.write) ? globalThis.Boolean(object.write) : false,
      owner: isSet(object.owner) ? globalThis.Boolean(object.owner) : false,
    };
  },

  toJSON(message: KeyBucketPermissions): unknown {
    const obj: any = {};
    if (message.read !== false) {
      obj.read = message.read;
    }
    if (message.write !== false) {
      obj.write = message.write;
    }
    if (message.owner !== false) {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyBucketPermissions>, I>>(base?: I): KeyBucketPermissions {
    return KeyBucketPermissions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyBucketPermissions>, I>>(object: I): KeyBucketPermissions {
    const message = createBaseKeyBucketPermissions();
    message.read = object.read ?? false;
    message.write = object.write ?? false;
    message.owner = object.owner ?? false;
    return message;
  },
};

/** Access Key Service - gRPC API for access key management */
export interface AccessKeyService {
  /** Query operations */
  ListKey(request: ListKeysRequest): Promise<ListKeysResponse>;
  ReadKey(request: ReadKeyRequest): Promise<KeyResponse>;
  /** Command operations */
  CreateKey(request: CreateKeyRequest): Promise<KeyResponse>;
  UpdateKey(request: UpdateKeyRequest): Promise<KeyResponse>;
  DeleteKey(request: DeleteKeyRequest): Promise<DeleteKeyResponse>;
}

export const AccessKeyServiceServiceName = "access_key.AccessKeyService";
export class AccessKeyServiceClientImpl implements AccessKeyService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AccessKeyServiceServiceName;
    this.rpc = rpc;
    this.ListKey = this.ListKey.bind(this);
    this.ReadKey = this.ReadKey.bind(this);
    this.CreateKey = this.CreateKey.bind(this);
    this.UpdateKey = this.UpdateKey.bind(this);
    this.DeleteKey = this.DeleteKey.bind(this);
  }
  ListKey(request: ListKeysRequest): Promise<ListKeysResponse> {
    const data = ListKeysRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListKey", data);
    return promise.then((data) => ListKeysResponse.decode(new BinaryReader(data)));
  }

  ReadKey(request: ReadKeyRequest): Promise<KeyResponse> {
    const data = ReadKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ReadKey", data);
    return promise.then((data) => KeyResponse.decode(new BinaryReader(data)));
  }

  CreateKey(request: CreateKeyRequest): Promise<KeyResponse> {
    const data = CreateKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateKey", data);
    return promise.then((data) => KeyResponse.decode(new BinaryReader(data)));
  }

  UpdateKey(request: UpdateKeyRequest): Promise<KeyResponse> {
    const data = UpdateKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateKey", data);
    return promise.then((data) => KeyResponse.decode(new BinaryReader(data)));
  }

  DeleteKey(request: DeleteKeyRequest): Promise<DeleteKeyResponse> {
    const data = DeleteKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteKey", data);
    return promise.then((data) => DeleteKeyResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
