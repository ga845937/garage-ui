// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v5.29.3
// source: cluster.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "cluster";

/** Unified API response with trace_id */
export interface ApiResponse {
  trace_id: string;
  cluster_status?: ClusterStatusData | undefined;
  cluster_health?: ClusterHealthData | undefined;
  cluster_layout?: ClusterLayoutData | undefined;
  layout_history?: LayoutHistoryData | undefined;
  preview_layout?: ApplyLayoutResultData | undefined;
  connect_nodes?: ConnectNodesData | undefined;
  update_layout?: ClusterLayoutData | undefined;
  apply_layout?: ApplyLayoutResultData | undefined;
  revert_layout?: ClusterLayoutData | undefined;
  skip_dead_nodes?: SkipDeadNodesData | undefined;
}

export interface ClusterStatusData {
  layout_version: number;
  nodes: ClusterNode[];
}

export interface ClusterHealthData {
  status: string;
  known_nodes: number;
  connected_nodes: number;
  storage_nodes: number;
  storage_nodes_ok: number;
  partitions: number;
  partitions_quorum: number;
  partitions_all_ok: number;
}

export interface ClusterLayoutData {
  version: number;
  roles: LayoutRole[];
  staged_role_changes: StagedRoleChange[];
  parameters: LayoutParameters | undefined;
}

export interface LayoutHistoryData {
  versions: LayoutVersion[];
  update_tracker: UpdateTracker | undefined;
}

export interface ApplyLayoutResultData {
  current_layout_version: number;
  partition_info: PartitionInfo[];
}

export interface ConnectNodesData {
  results: ConnectNodeResult[];
}

export interface SkipDeadNodesData {
  current_layout_version: number;
  partition_info: PartitionInfo[];
}

export interface GetClusterStatusRequest {
}

export interface GetClusterHealthRequest {
}

export interface GetClusterLayoutRequest {
}

export interface GetLayoutHistoryRequest {
}

export interface PreviewLayoutChangesRequest {
}

export interface ConnectNodesRequest {
  node_addresses: string[];
}

export interface UpdateLayoutRequest {
  role_changes: LayoutRoleChange[];
}

export interface LayoutRoleChange {
  node_id: string;
  zone?: string | undefined;
  capacity?: number | undefined;
  tags: string[];
  remove: boolean;
}

export interface ApplyLayoutRequest {
  version: number;
}

export interface RevertLayoutRequest {
}

export interface SkipDeadNodesRequest {
  version: number;
  allow_missing_data: boolean;
}

export interface ClusterNode {
  id: string;
  role: string;
  addr?: string | undefined;
  hostname: string;
  is_up: boolean;
  last_seen_secs_ago: number;
  cluster_layout_current: boolean;
  cluster_layout_staging?: number | undefined;
}

export interface LayoutRole {
  id: string;
  zone: string;
  capacity: number;
  tags: string[];
}

export interface StagedRoleChange {
  id: string;
  role?: LayoutRole | undefined;
  remove: boolean;
}

export interface LayoutParameters {
  zone_redundancy: ZoneRedundancy | undefined;
}

export interface ZoneRedundancy {
  fixed?: number | undefined;
  maximum?: boolean | undefined;
}

export interface ConnectNodeResult {
  success: boolean;
  error?: string | undefined;
}

export interface PartitionInfo {
  partition: number;
  nodes: string[];
}

export interface LayoutVersion {
  version: number;
  update_time: string;
}

export interface UpdateTracker {
  nodes: NodeUpdateProgress[];
}

export interface NodeUpdateProgress {
  node_id: string;
  sync_version?: number | undefined;
  write_version?: number | undefined;
}

function createBaseApiResponse(): ApiResponse {
  return {
    trace_id: "",
    cluster_status: undefined,
    cluster_health: undefined,
    cluster_layout: undefined,
    layout_history: undefined,
    preview_layout: undefined,
    connect_nodes: undefined,
    update_layout: undefined,
    apply_layout: undefined,
    revert_layout: undefined,
    skip_dead_nodes: undefined,
  };
}

export const ApiResponse: MessageFns<ApiResponse> = {
  encode(message: ApiResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.cluster_status !== undefined) {
      ClusterStatusData.encode(message.cluster_status, writer.uint32(18).fork()).join();
    }
    if (message.cluster_health !== undefined) {
      ClusterHealthData.encode(message.cluster_health, writer.uint32(26).fork()).join();
    }
    if (message.cluster_layout !== undefined) {
      ClusterLayoutData.encode(message.cluster_layout, writer.uint32(34).fork()).join();
    }
    if (message.layout_history !== undefined) {
      LayoutHistoryData.encode(message.layout_history, writer.uint32(42).fork()).join();
    }
    if (message.preview_layout !== undefined) {
      ApplyLayoutResultData.encode(message.preview_layout, writer.uint32(50).fork()).join();
    }
    if (message.connect_nodes !== undefined) {
      ConnectNodesData.encode(message.connect_nodes, writer.uint32(58).fork()).join();
    }
    if (message.update_layout !== undefined) {
      ClusterLayoutData.encode(message.update_layout, writer.uint32(66).fork()).join();
    }
    if (message.apply_layout !== undefined) {
      ApplyLayoutResultData.encode(message.apply_layout, writer.uint32(74).fork()).join();
    }
    if (message.revert_layout !== undefined) {
      ClusterLayoutData.encode(message.revert_layout, writer.uint32(82).fork()).join();
    }
    if (message.skip_dead_nodes !== undefined) {
      SkipDeadNodesData.encode(message.skip_dead_nodes, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster_status = ClusterStatusData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cluster_health = ClusterHealthData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cluster_layout = ClusterLayoutData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.layout_history = LayoutHistoryData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.preview_layout = ApplyLayoutResultData.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.connect_nodes = ConnectNodesData.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.update_layout = ClusterLayoutData.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.apply_layout = ApplyLayoutResultData.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.revert_layout = ClusterLayoutData.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skip_dead_nodes = SkipDeadNodesData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      cluster_status: isSet(object.clusterStatus)
        ? ClusterStatusData.fromJSON(object.clusterStatus)
        : isSet(object.cluster_status)
        ? ClusterStatusData.fromJSON(object.cluster_status)
        : undefined,
      cluster_health: isSet(object.clusterHealth)
        ? ClusterHealthData.fromJSON(object.clusterHealth)
        : isSet(object.cluster_health)
        ? ClusterHealthData.fromJSON(object.cluster_health)
        : undefined,
      cluster_layout: isSet(object.clusterLayout)
        ? ClusterLayoutData.fromJSON(object.clusterLayout)
        : isSet(object.cluster_layout)
        ? ClusterLayoutData.fromJSON(object.cluster_layout)
        : undefined,
      layout_history: isSet(object.layoutHistory)
        ? LayoutHistoryData.fromJSON(object.layoutHistory)
        : isSet(object.layout_history)
        ? LayoutHistoryData.fromJSON(object.layout_history)
        : undefined,
      preview_layout: isSet(object.previewLayout)
        ? ApplyLayoutResultData.fromJSON(object.previewLayout)
        : isSet(object.preview_layout)
        ? ApplyLayoutResultData.fromJSON(object.preview_layout)
        : undefined,
      connect_nodes: isSet(object.connectNodes)
        ? ConnectNodesData.fromJSON(object.connectNodes)
        : isSet(object.connect_nodes)
        ? ConnectNodesData.fromJSON(object.connect_nodes)
        : undefined,
      update_layout: isSet(object.updateLayout)
        ? ClusterLayoutData.fromJSON(object.updateLayout)
        : isSet(object.update_layout)
        ? ClusterLayoutData.fromJSON(object.update_layout)
        : undefined,
      apply_layout: isSet(object.applyLayout)
        ? ApplyLayoutResultData.fromJSON(object.applyLayout)
        : isSet(object.apply_layout)
        ? ApplyLayoutResultData.fromJSON(object.apply_layout)
        : undefined,
      revert_layout: isSet(object.revertLayout)
        ? ClusterLayoutData.fromJSON(object.revertLayout)
        : isSet(object.revert_layout)
        ? ClusterLayoutData.fromJSON(object.revert_layout)
        : undefined,
      skip_dead_nodes: isSet(object.skipDeadNodes)
        ? SkipDeadNodesData.fromJSON(object.skipDeadNodes)
        : isSet(object.skip_dead_nodes)
        ? SkipDeadNodesData.fromJSON(object.skip_dead_nodes)
        : undefined,
    };
  },

  toJSON(message: ApiResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.cluster_status !== undefined) {
      obj.clusterStatus = ClusterStatusData.toJSON(message.cluster_status);
    }
    if (message.cluster_health !== undefined) {
      obj.clusterHealth = ClusterHealthData.toJSON(message.cluster_health);
    }
    if (message.cluster_layout !== undefined) {
      obj.clusterLayout = ClusterLayoutData.toJSON(message.cluster_layout);
    }
    if (message.layout_history !== undefined) {
      obj.layoutHistory = LayoutHistoryData.toJSON(message.layout_history);
    }
    if (message.preview_layout !== undefined) {
      obj.previewLayout = ApplyLayoutResultData.toJSON(message.preview_layout);
    }
    if (message.connect_nodes !== undefined) {
      obj.connectNodes = ConnectNodesData.toJSON(message.connect_nodes);
    }
    if (message.update_layout !== undefined) {
      obj.updateLayout = ClusterLayoutData.toJSON(message.update_layout);
    }
    if (message.apply_layout !== undefined) {
      obj.applyLayout = ApplyLayoutResultData.toJSON(message.apply_layout);
    }
    if (message.revert_layout !== undefined) {
      obj.revertLayout = ClusterLayoutData.toJSON(message.revert_layout);
    }
    if (message.skip_dead_nodes !== undefined) {
      obj.skipDeadNodes = SkipDeadNodesData.toJSON(message.skip_dead_nodes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiResponse>, I>>(base?: I): ApiResponse {
    return ApiResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiResponse>, I>>(object: I): ApiResponse {
    const message = createBaseApiResponse();
    message.trace_id = object.trace_id ?? "";
    message.cluster_status = (object.cluster_status !== undefined && object.cluster_status !== null)
      ? ClusterStatusData.fromPartial(object.cluster_status)
      : undefined;
    message.cluster_health = (object.cluster_health !== undefined && object.cluster_health !== null)
      ? ClusterHealthData.fromPartial(object.cluster_health)
      : undefined;
    message.cluster_layout = (object.cluster_layout !== undefined && object.cluster_layout !== null)
      ? ClusterLayoutData.fromPartial(object.cluster_layout)
      : undefined;
    message.layout_history = (object.layout_history !== undefined && object.layout_history !== null)
      ? LayoutHistoryData.fromPartial(object.layout_history)
      : undefined;
    message.preview_layout = (object.preview_layout !== undefined && object.preview_layout !== null)
      ? ApplyLayoutResultData.fromPartial(object.preview_layout)
      : undefined;
    message.connect_nodes = (object.connect_nodes !== undefined && object.connect_nodes !== null)
      ? ConnectNodesData.fromPartial(object.connect_nodes)
      : undefined;
    message.update_layout = (object.update_layout !== undefined && object.update_layout !== null)
      ? ClusterLayoutData.fromPartial(object.update_layout)
      : undefined;
    message.apply_layout = (object.apply_layout !== undefined && object.apply_layout !== null)
      ? ApplyLayoutResultData.fromPartial(object.apply_layout)
      : undefined;
    message.revert_layout = (object.revert_layout !== undefined && object.revert_layout !== null)
      ? ClusterLayoutData.fromPartial(object.revert_layout)
      : undefined;
    message.skip_dead_nodes = (object.skip_dead_nodes !== undefined && object.skip_dead_nodes !== null)
      ? SkipDeadNodesData.fromPartial(object.skip_dead_nodes)
      : undefined;
    return message;
  },
};

function createBaseClusterStatusData(): ClusterStatusData {
  return { layout_version: 0, nodes: [] };
}

export const ClusterStatusData: MessageFns<ClusterStatusData> = {
  encode(message: ClusterStatusData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout_version !== 0) {
      writer.uint32(8).int64(message.layout_version);
    }
    for (const v of message.nodes) {
      ClusterNode.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterStatusData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterStatusData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.layout_version = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodes.push(ClusterNode.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterStatusData {
    return {
      layout_version: isSet(object.layoutVersion)
        ? globalThis.Number(object.layoutVersion)
        : isSet(object.layout_version)
        ? globalThis.Number(object.layout_version)
        : 0,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => ClusterNode.fromJSON(e)) : [],
    };
  },

  toJSON(message: ClusterStatusData): unknown {
    const obj: any = {};
    if (message.layout_version !== 0) {
      obj.layoutVersion = Math.round(message.layout_version);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => ClusterNode.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterStatusData>, I>>(base?: I): ClusterStatusData {
    return ClusterStatusData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterStatusData>, I>>(object: I): ClusterStatusData {
    const message = createBaseClusterStatusData();
    message.layout_version = object.layout_version ?? 0;
    message.nodes = object.nodes?.map((e) => ClusterNode.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClusterHealthData(): ClusterHealthData {
  return {
    status: "",
    known_nodes: 0,
    connected_nodes: 0,
    storage_nodes: 0,
    storage_nodes_ok: 0,
    partitions: 0,
    partitions_quorum: 0,
    partitions_all_ok: 0,
  };
}

export const ClusterHealthData: MessageFns<ClusterHealthData> = {
  encode(message: ClusterHealthData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.known_nodes !== 0) {
      writer.uint32(16).int32(message.known_nodes);
    }
    if (message.connected_nodes !== 0) {
      writer.uint32(24).int32(message.connected_nodes);
    }
    if (message.storage_nodes !== 0) {
      writer.uint32(32).int32(message.storage_nodes);
    }
    if (message.storage_nodes_ok !== 0) {
      writer.uint32(40).int32(message.storage_nodes_ok);
    }
    if (message.partitions !== 0) {
      writer.uint32(48).int32(message.partitions);
    }
    if (message.partitions_quorum !== 0) {
      writer.uint32(56).int32(message.partitions_quorum);
    }
    if (message.partitions_all_ok !== 0) {
      writer.uint32(64).int32(message.partitions_all_ok);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterHealthData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterHealthData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.known_nodes = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.connected_nodes = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.storage_nodes = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storage_nodes_ok = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.partitions = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.partitions_quorum = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.partitions_all_ok = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterHealthData {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      known_nodes: isSet(object.knownNodes)
        ? globalThis.Number(object.knownNodes)
        : isSet(object.known_nodes)
        ? globalThis.Number(object.known_nodes)
        : 0,
      connected_nodes: isSet(object.connectedNodes)
        ? globalThis.Number(object.connectedNodes)
        : isSet(object.connected_nodes)
        ? globalThis.Number(object.connected_nodes)
        : 0,
      storage_nodes: isSet(object.storageNodes)
        ? globalThis.Number(object.storageNodes)
        : isSet(object.storage_nodes)
        ? globalThis.Number(object.storage_nodes)
        : 0,
      storage_nodes_ok: isSet(object.storageNodesOk)
        ? globalThis.Number(object.storageNodesOk)
        : isSet(object.storage_nodes_ok)
        ? globalThis.Number(object.storage_nodes_ok)
        : 0,
      partitions: isSet(object.partitions) ? globalThis.Number(object.partitions) : 0,
      partitions_quorum: isSet(object.partitionsQuorum)
        ? globalThis.Number(object.partitionsQuorum)
        : isSet(object.partitions_quorum)
        ? globalThis.Number(object.partitions_quorum)
        : 0,
      partitions_all_ok: isSet(object.partitionsAllOk)
        ? globalThis.Number(object.partitionsAllOk)
        : isSet(object.partitions_all_ok)
        ? globalThis.Number(object.partitions_all_ok)
        : 0,
    };
  },

  toJSON(message: ClusterHealthData): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.known_nodes !== 0) {
      obj.knownNodes = Math.round(message.known_nodes);
    }
    if (message.connected_nodes !== 0) {
      obj.connectedNodes = Math.round(message.connected_nodes);
    }
    if (message.storage_nodes !== 0) {
      obj.storageNodes = Math.round(message.storage_nodes);
    }
    if (message.storage_nodes_ok !== 0) {
      obj.storageNodesOk = Math.round(message.storage_nodes_ok);
    }
    if (message.partitions !== 0) {
      obj.partitions = Math.round(message.partitions);
    }
    if (message.partitions_quorum !== 0) {
      obj.partitionsQuorum = Math.round(message.partitions_quorum);
    }
    if (message.partitions_all_ok !== 0) {
      obj.partitionsAllOk = Math.round(message.partitions_all_ok);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterHealthData>, I>>(base?: I): ClusterHealthData {
    return ClusterHealthData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterHealthData>, I>>(object: I): ClusterHealthData {
    const message = createBaseClusterHealthData();
    message.status = object.status ?? "";
    message.known_nodes = object.known_nodes ?? 0;
    message.connected_nodes = object.connected_nodes ?? 0;
    message.storage_nodes = object.storage_nodes ?? 0;
    message.storage_nodes_ok = object.storage_nodes_ok ?? 0;
    message.partitions = object.partitions ?? 0;
    message.partitions_quorum = object.partitions_quorum ?? 0;
    message.partitions_all_ok = object.partitions_all_ok ?? 0;
    return message;
  },
};

function createBaseClusterLayoutData(): ClusterLayoutData {
  return { version: 0, roles: [], staged_role_changes: [], parameters: undefined };
}

export const ClusterLayoutData: MessageFns<ClusterLayoutData> = {
  encode(message: ClusterLayoutData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int64(message.version);
    }
    for (const v of message.roles) {
      LayoutRole.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.staged_role_changes) {
      StagedRoleChange.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.parameters !== undefined) {
      LayoutParameters.encode(message.parameters, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterLayoutData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterLayoutData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roles.push(LayoutRole.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.staged_role_changes.push(StagedRoleChange.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameters = LayoutParameters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterLayoutData {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => LayoutRole.fromJSON(e)) : [],
      staged_role_changes: globalThis.Array.isArray(object?.stagedRoleChanges)
        ? object.stagedRoleChanges.map((e: any) => StagedRoleChange.fromJSON(e))
        : globalThis.Array.isArray(object?.staged_role_changes)
        ? object.staged_role_changes.map((e: any) => StagedRoleChange.fromJSON(e))
        : [],
      parameters: isSet(object.parameters) ? LayoutParameters.fromJSON(object.parameters) : undefined,
    };
  },

  toJSON(message: ClusterLayoutData): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => LayoutRole.toJSON(e));
    }
    if (message.staged_role_changes?.length) {
      obj.stagedRoleChanges = message.staged_role_changes.map((e) => StagedRoleChange.toJSON(e));
    }
    if (message.parameters !== undefined) {
      obj.parameters = LayoutParameters.toJSON(message.parameters);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterLayoutData>, I>>(base?: I): ClusterLayoutData {
    return ClusterLayoutData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterLayoutData>, I>>(object: I): ClusterLayoutData {
    const message = createBaseClusterLayoutData();
    message.version = object.version ?? 0;
    message.roles = object.roles?.map((e) => LayoutRole.fromPartial(e)) || [];
    message.staged_role_changes = object.staged_role_changes?.map((e) => StagedRoleChange.fromPartial(e)) || [];
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? LayoutParameters.fromPartial(object.parameters)
      : undefined;
    return message;
  },
};

function createBaseLayoutHistoryData(): LayoutHistoryData {
  return { versions: [], update_tracker: undefined };
}

export const LayoutHistoryData: MessageFns<LayoutHistoryData> = {
  encode(message: LayoutHistoryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.versions) {
      LayoutVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.update_tracker !== undefined) {
      UpdateTracker.encode(message.update_tracker, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayoutHistoryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayoutHistoryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versions.push(LayoutVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.update_tracker = UpdateTracker.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayoutHistoryData {
    return {
      versions: globalThis.Array.isArray(object?.versions)
        ? object.versions.map((e: any) => LayoutVersion.fromJSON(e))
        : [],
      update_tracker: isSet(object.updateTracker)
        ? UpdateTracker.fromJSON(object.updateTracker)
        : isSet(object.update_tracker)
        ? UpdateTracker.fromJSON(object.update_tracker)
        : undefined,
    };
  },

  toJSON(message: LayoutHistoryData): unknown {
    const obj: any = {};
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => LayoutVersion.toJSON(e));
    }
    if (message.update_tracker !== undefined) {
      obj.updateTracker = UpdateTracker.toJSON(message.update_tracker);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayoutHistoryData>, I>>(base?: I): LayoutHistoryData {
    return LayoutHistoryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayoutHistoryData>, I>>(object: I): LayoutHistoryData {
    const message = createBaseLayoutHistoryData();
    message.versions = object.versions?.map((e) => LayoutVersion.fromPartial(e)) || [];
    message.update_tracker = (object.update_tracker !== undefined && object.update_tracker !== null)
      ? UpdateTracker.fromPartial(object.update_tracker)
      : undefined;
    return message;
  },
};

function createBaseApplyLayoutResultData(): ApplyLayoutResultData {
  return { current_layout_version: 0, partition_info: [] };
}

export const ApplyLayoutResultData: MessageFns<ApplyLayoutResultData> = {
  encode(message: ApplyLayoutResultData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.current_layout_version !== 0) {
      writer.uint32(8).int64(message.current_layout_version);
    }
    for (const v of message.partition_info) {
      PartitionInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyLayoutResultData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyLayoutResultData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.current_layout_version = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partition_info.push(PartitionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyLayoutResultData {
    return {
      current_layout_version: isSet(object.currentLayoutVersion)
        ? globalThis.Number(object.currentLayoutVersion)
        : isSet(object.current_layout_version)
        ? globalThis.Number(object.current_layout_version)
        : 0,
      partition_info: globalThis.Array.isArray(object?.partitionInfo)
        ? object.partitionInfo.map((e: any) => PartitionInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.partition_info)
        ? object.partition_info.map((e: any) => PartitionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ApplyLayoutResultData): unknown {
    const obj: any = {};
    if (message.current_layout_version !== 0) {
      obj.currentLayoutVersion = Math.round(message.current_layout_version);
    }
    if (message.partition_info?.length) {
      obj.partitionInfo = message.partition_info.map((e) => PartitionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyLayoutResultData>, I>>(base?: I): ApplyLayoutResultData {
    return ApplyLayoutResultData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyLayoutResultData>, I>>(object: I): ApplyLayoutResultData {
    const message = createBaseApplyLayoutResultData();
    message.current_layout_version = object.current_layout_version ?? 0;
    message.partition_info = object.partition_info?.map((e) => PartitionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConnectNodesData(): ConnectNodesData {
  return { results: [] };
}

export const ConnectNodesData: MessageFns<ConnectNodesData> = {
  encode(message: ConnectNodesData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      ConnectNodeResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectNodesData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectNodesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(ConnectNodeResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectNodesData {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ConnectNodeResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConnectNodesData): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => ConnectNodeResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectNodesData>, I>>(base?: I): ConnectNodesData {
    return ConnectNodesData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectNodesData>, I>>(object: I): ConnectNodesData {
    const message = createBaseConnectNodesData();
    message.results = object.results?.map((e) => ConnectNodeResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkipDeadNodesData(): SkipDeadNodesData {
  return { current_layout_version: 0, partition_info: [] };
}

export const SkipDeadNodesData: MessageFns<SkipDeadNodesData> = {
  encode(message: SkipDeadNodesData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.current_layout_version !== 0) {
      writer.uint32(8).int64(message.current_layout_version);
    }
    for (const v of message.partition_info) {
      PartitionInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkipDeadNodesData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkipDeadNodesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.current_layout_version = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partition_info.push(PartitionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkipDeadNodesData {
    return {
      current_layout_version: isSet(object.currentLayoutVersion)
        ? globalThis.Number(object.currentLayoutVersion)
        : isSet(object.current_layout_version)
        ? globalThis.Number(object.current_layout_version)
        : 0,
      partition_info: globalThis.Array.isArray(object?.partitionInfo)
        ? object.partitionInfo.map((e: any) => PartitionInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.partition_info)
        ? object.partition_info.map((e: any) => PartitionInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SkipDeadNodesData): unknown {
    const obj: any = {};
    if (message.current_layout_version !== 0) {
      obj.currentLayoutVersion = Math.round(message.current_layout_version);
    }
    if (message.partition_info?.length) {
      obj.partitionInfo = message.partition_info.map((e) => PartitionInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkipDeadNodesData>, I>>(base?: I): SkipDeadNodesData {
    return SkipDeadNodesData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkipDeadNodesData>, I>>(object: I): SkipDeadNodesData {
    const message = createBaseSkipDeadNodesData();
    message.current_layout_version = object.current_layout_version ?? 0;
    message.partition_info = object.partition_info?.map((e) => PartitionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetClusterStatusRequest(): GetClusterStatusRequest {
  return {};
}

export const GetClusterStatusRequest: MessageFns<GetClusterStatusRequest> = {
  encode(_: GetClusterStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClusterStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClusterStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetClusterStatusRequest {
    return {};
  },

  toJSON(_: GetClusterStatusRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClusterStatusRequest>, I>>(base?: I): GetClusterStatusRequest {
    return GetClusterStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClusterStatusRequest>, I>>(_: I): GetClusterStatusRequest {
    const message = createBaseGetClusterStatusRequest();
    return message;
  },
};

function createBaseGetClusterHealthRequest(): GetClusterHealthRequest {
  return {};
}

export const GetClusterHealthRequest: MessageFns<GetClusterHealthRequest> = {
  encode(_: GetClusterHealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClusterHealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClusterHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetClusterHealthRequest {
    return {};
  },

  toJSON(_: GetClusterHealthRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClusterHealthRequest>, I>>(base?: I): GetClusterHealthRequest {
    return GetClusterHealthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClusterHealthRequest>, I>>(_: I): GetClusterHealthRequest {
    const message = createBaseGetClusterHealthRequest();
    return message;
  },
};

function createBaseGetClusterLayoutRequest(): GetClusterLayoutRequest {
  return {};
}

export const GetClusterLayoutRequest: MessageFns<GetClusterLayoutRequest> = {
  encode(_: GetClusterLayoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClusterLayoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClusterLayoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetClusterLayoutRequest {
    return {};
  },

  toJSON(_: GetClusterLayoutRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClusterLayoutRequest>, I>>(base?: I): GetClusterLayoutRequest {
    return GetClusterLayoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClusterLayoutRequest>, I>>(_: I): GetClusterLayoutRequest {
    const message = createBaseGetClusterLayoutRequest();
    return message;
  },
};

function createBaseGetLayoutHistoryRequest(): GetLayoutHistoryRequest {
  return {};
}

export const GetLayoutHistoryRequest: MessageFns<GetLayoutHistoryRequest> = {
  encode(_: GetLayoutHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLayoutHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLayoutHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetLayoutHistoryRequest {
    return {};
  },

  toJSON(_: GetLayoutHistoryRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLayoutHistoryRequest>, I>>(base?: I): GetLayoutHistoryRequest {
    return GetLayoutHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLayoutHistoryRequest>, I>>(_: I): GetLayoutHistoryRequest {
    const message = createBaseGetLayoutHistoryRequest();
    return message;
  },
};

function createBasePreviewLayoutChangesRequest(): PreviewLayoutChangesRequest {
  return {};
}

export const PreviewLayoutChangesRequest: MessageFns<PreviewLayoutChangesRequest> = {
  encode(_: PreviewLayoutChangesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreviewLayoutChangesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewLayoutChangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PreviewLayoutChangesRequest {
    return {};
  },

  toJSON(_: PreviewLayoutChangesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviewLayoutChangesRequest>, I>>(base?: I): PreviewLayoutChangesRequest {
    return PreviewLayoutChangesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviewLayoutChangesRequest>, I>>(_: I): PreviewLayoutChangesRequest {
    const message = createBasePreviewLayoutChangesRequest();
    return message;
  },
};

function createBaseConnectNodesRequest(): ConnectNodesRequest {
  return { node_addresses: [] };
}

export const ConnectNodesRequest: MessageFns<ConnectNodesRequest> = {
  encode(message: ConnectNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.node_addresses) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node_addresses.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectNodesRequest {
    return {
      node_addresses: globalThis.Array.isArray(object?.nodeAddresses)
        ? object.nodeAddresses.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.node_addresses)
        ? object.node_addresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConnectNodesRequest): unknown {
    const obj: any = {};
    if (message.node_addresses?.length) {
      obj.nodeAddresses = message.node_addresses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectNodesRequest>, I>>(base?: I): ConnectNodesRequest {
    return ConnectNodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectNodesRequest>, I>>(object: I): ConnectNodesRequest {
    const message = createBaseConnectNodesRequest();
    message.node_addresses = object.node_addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateLayoutRequest(): UpdateLayoutRequest {
  return { role_changes: [] };
}

export const UpdateLayoutRequest: MessageFns<UpdateLayoutRequest> = {
  encode(message: UpdateLayoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.role_changes) {
      LayoutRoleChange.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLayoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLayoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role_changes.push(LayoutRoleChange.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLayoutRequest {
    return {
      role_changes: globalThis.Array.isArray(object?.roleChanges)
        ? object.roleChanges.map((e: any) => LayoutRoleChange.fromJSON(e))
        : globalThis.Array.isArray(object?.role_changes)
        ? object.role_changes.map((e: any) => LayoutRoleChange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateLayoutRequest): unknown {
    const obj: any = {};
    if (message.role_changes?.length) {
      obj.roleChanges = message.role_changes.map((e) => LayoutRoleChange.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateLayoutRequest>, I>>(base?: I): UpdateLayoutRequest {
    return UpdateLayoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateLayoutRequest>, I>>(object: I): UpdateLayoutRequest {
    const message = createBaseUpdateLayoutRequest();
    message.role_changes = object.role_changes?.map((e) => LayoutRoleChange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLayoutRoleChange(): LayoutRoleChange {
  return { node_id: "", zone: undefined, capacity: undefined, tags: [], remove: false };
}

export const LayoutRoleChange: MessageFns<LayoutRoleChange> = {
  encode(message: LayoutRoleChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node_id !== "") {
      writer.uint32(10).string(message.node_id);
    }
    if (message.zone !== undefined) {
      writer.uint32(18).string(message.zone);
    }
    if (message.capacity !== undefined) {
      writer.uint32(24).int64(message.capacity);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.remove !== false) {
      writer.uint32(40).bool(message.remove);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayoutRoleChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayoutRoleChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.capacity = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.remove = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayoutRoleChange {
    return {
      node_id: isSet(object.nodeId)
        ? globalThis.String(object.nodeId)
        : isSet(object.node_id)
        ? globalThis.String(object.node_id)
        : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : undefined,
      capacity: isSet(object.capacity) ? globalThis.Number(object.capacity) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      remove: isSet(object.remove) ? globalThis.Boolean(object.remove) : false,
    };
  },

  toJSON(message: LayoutRoleChange): unknown {
    const obj: any = {};
    if (message.node_id !== "") {
      obj.nodeId = message.node_id;
    }
    if (message.zone !== undefined) {
      obj.zone = message.zone;
    }
    if (message.capacity !== undefined) {
      obj.capacity = Math.round(message.capacity);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.remove !== false) {
      obj.remove = message.remove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayoutRoleChange>, I>>(base?: I): LayoutRoleChange {
    return LayoutRoleChange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayoutRoleChange>, I>>(object: I): LayoutRoleChange {
    const message = createBaseLayoutRoleChange();
    message.node_id = object.node_id ?? "";
    message.zone = object.zone ?? undefined;
    message.capacity = object.capacity ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.remove = object.remove ?? false;
    return message;
  },
};

function createBaseApplyLayoutRequest(): ApplyLayoutRequest {
  return { version: 0 };
}

export const ApplyLayoutRequest: MessageFns<ApplyLayoutRequest> = {
  encode(message: ApplyLayoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyLayoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyLayoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyLayoutRequest {
    return { version: isSet(object.version) ? globalThis.Number(object.version) : 0 };
  },

  toJSON(message: ApplyLayoutRequest): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyLayoutRequest>, I>>(base?: I): ApplyLayoutRequest {
    return ApplyLayoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyLayoutRequest>, I>>(object: I): ApplyLayoutRequest {
    const message = createBaseApplyLayoutRequest();
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseRevertLayoutRequest(): RevertLayoutRequest {
  return {};
}

export const RevertLayoutRequest: MessageFns<RevertLayoutRequest> = {
  encode(_: RevertLayoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevertLayoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevertLayoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RevertLayoutRequest {
    return {};
  },

  toJSON(_: RevertLayoutRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RevertLayoutRequest>, I>>(base?: I): RevertLayoutRequest {
    return RevertLayoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevertLayoutRequest>, I>>(_: I): RevertLayoutRequest {
    const message = createBaseRevertLayoutRequest();
    return message;
  },
};

function createBaseSkipDeadNodesRequest(): SkipDeadNodesRequest {
  return { version: 0, allow_missing_data: false };
}

export const SkipDeadNodesRequest: MessageFns<SkipDeadNodesRequest> = {
  encode(message: SkipDeadNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int64(message.version);
    }
    if (message.allow_missing_data !== false) {
      writer.uint32(16).bool(message.allow_missing_data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkipDeadNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkipDeadNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allow_missing_data = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkipDeadNodesRequest {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      allow_missing_data: isSet(object.allowMissingData)
        ? globalThis.Boolean(object.allowMissingData)
        : isSet(object.allow_missing_data)
        ? globalThis.Boolean(object.allow_missing_data)
        : false,
    };
  },

  toJSON(message: SkipDeadNodesRequest): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.allow_missing_data !== false) {
      obj.allowMissingData = message.allow_missing_data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkipDeadNodesRequest>, I>>(base?: I): SkipDeadNodesRequest {
    return SkipDeadNodesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkipDeadNodesRequest>, I>>(object: I): SkipDeadNodesRequest {
    const message = createBaseSkipDeadNodesRequest();
    message.version = object.version ?? 0;
    message.allow_missing_data = object.allow_missing_data ?? false;
    return message;
  },
};

function createBaseClusterNode(): ClusterNode {
  return {
    id: "",
    role: "",
    addr: undefined,
    hostname: "",
    is_up: false,
    last_seen_secs_ago: 0,
    cluster_layout_current: false,
    cluster_layout_staging: undefined,
  };
}

export const ClusterNode: MessageFns<ClusterNode> = {
  encode(message: ClusterNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.addr !== undefined) {
      writer.uint32(26).string(message.addr);
    }
    if (message.hostname !== "") {
      writer.uint32(34).string(message.hostname);
    }
    if (message.is_up !== false) {
      writer.uint32(40).bool(message.is_up);
    }
    if (message.last_seen_secs_ago !== 0) {
      writer.uint32(48).int64(message.last_seen_secs_ago);
    }
    if (message.cluster_layout_current !== false) {
      writer.uint32(56).bool(message.cluster_layout_current);
    }
    if (message.cluster_layout_staging !== undefined) {
      writer.uint32(64).int64(message.cluster_layout_staging);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.is_up = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.last_seen_secs_ago = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cluster_layout_current = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cluster_layout_staging = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      addr: isSet(object.addr) ? globalThis.String(object.addr) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      is_up: isSet(object.isUp)
        ? globalThis.Boolean(object.isUp)
        : isSet(object.is_up)
        ? globalThis.Boolean(object.is_up)
        : false,
      last_seen_secs_ago: isSet(object.lastSeenSecsAgo)
        ? globalThis.Number(object.lastSeenSecsAgo)
        : isSet(object.last_seen_secs_ago)
        ? globalThis.Number(object.last_seen_secs_ago)
        : 0,
      cluster_layout_current: isSet(object.clusterLayoutCurrent)
        ? globalThis.Boolean(object.clusterLayoutCurrent)
        : isSet(object.cluster_layout_current)
        ? globalThis.Boolean(object.cluster_layout_current)
        : false,
      cluster_layout_staging: isSet(object.clusterLayoutStaging)
        ? globalThis.Number(object.clusterLayoutStaging)
        : isSet(object.cluster_layout_staging)
        ? globalThis.Number(object.cluster_layout_staging)
        : undefined,
    };
  },

  toJSON(message: ClusterNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.addr !== undefined) {
      obj.addr = message.addr;
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.is_up !== false) {
      obj.isUp = message.is_up;
    }
    if (message.last_seen_secs_ago !== 0) {
      obj.lastSeenSecsAgo = Math.round(message.last_seen_secs_ago);
    }
    if (message.cluster_layout_current !== false) {
      obj.clusterLayoutCurrent = message.cluster_layout_current;
    }
    if (message.cluster_layout_staging !== undefined) {
      obj.clusterLayoutStaging = Math.round(message.cluster_layout_staging);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClusterNode>, I>>(base?: I): ClusterNode {
    return ClusterNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClusterNode>, I>>(object: I): ClusterNode {
    const message = createBaseClusterNode();
    message.id = object.id ?? "";
    message.role = object.role ?? "";
    message.addr = object.addr ?? undefined;
    message.hostname = object.hostname ?? "";
    message.is_up = object.is_up ?? false;
    message.last_seen_secs_ago = object.last_seen_secs_ago ?? 0;
    message.cluster_layout_current = object.cluster_layout_current ?? false;
    message.cluster_layout_staging = object.cluster_layout_staging ?? undefined;
    return message;
  },
};

function createBaseLayoutRole(): LayoutRole {
  return { id: "", zone: "", capacity: 0, tags: [] };
}

export const LayoutRole: MessageFns<LayoutRole> = {
  encode(message: LayoutRole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.capacity !== 0) {
      writer.uint32(24).int64(message.capacity);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayoutRole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayoutRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.capacity = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayoutRole {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      capacity: isSet(object.capacity) ? globalThis.Number(object.capacity) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: LayoutRole): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.capacity !== 0) {
      obj.capacity = Math.round(message.capacity);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayoutRole>, I>>(base?: I): LayoutRole {
    return LayoutRole.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayoutRole>, I>>(object: I): LayoutRole {
    const message = createBaseLayoutRole();
    message.id = object.id ?? "";
    message.zone = object.zone ?? "";
    message.capacity = object.capacity ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseStagedRoleChange(): StagedRoleChange {
  return { id: "", role: undefined, remove: false };
}

export const StagedRoleChange: MessageFns<StagedRoleChange> = {
  encode(message: StagedRoleChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.role !== undefined) {
      LayoutRole.encode(message.role, writer.uint32(18).fork()).join();
    }
    if (message.remove !== false) {
      writer.uint32(24).bool(message.remove);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StagedRoleChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStagedRoleChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = LayoutRole.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.remove = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StagedRoleChange {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      role: isSet(object.role) ? LayoutRole.fromJSON(object.role) : undefined,
      remove: isSet(object.remove) ? globalThis.Boolean(object.remove) : false,
    };
  },

  toJSON(message: StagedRoleChange): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.role !== undefined) {
      obj.role = LayoutRole.toJSON(message.role);
    }
    if (message.remove !== false) {
      obj.remove = message.remove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StagedRoleChange>, I>>(base?: I): StagedRoleChange {
    return StagedRoleChange.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StagedRoleChange>, I>>(object: I): StagedRoleChange {
    const message = createBaseStagedRoleChange();
    message.id = object.id ?? "";
    message.role = (object.role !== undefined && object.role !== null)
      ? LayoutRole.fromPartial(object.role)
      : undefined;
    message.remove = object.remove ?? false;
    return message;
  },
};

function createBaseLayoutParameters(): LayoutParameters {
  return { zone_redundancy: undefined };
}

export const LayoutParameters: MessageFns<LayoutParameters> = {
  encode(message: LayoutParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.zone_redundancy !== undefined) {
      ZoneRedundancy.encode(message.zone_redundancy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayoutParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayoutParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.zone_redundancy = ZoneRedundancy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayoutParameters {
    return {
      zone_redundancy: isSet(object.zoneRedundancy)
        ? ZoneRedundancy.fromJSON(object.zoneRedundancy)
        : isSet(object.zone_redundancy)
        ? ZoneRedundancy.fromJSON(object.zone_redundancy)
        : undefined,
    };
  },

  toJSON(message: LayoutParameters): unknown {
    const obj: any = {};
    if (message.zone_redundancy !== undefined) {
      obj.zoneRedundancy = ZoneRedundancy.toJSON(message.zone_redundancy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayoutParameters>, I>>(base?: I): LayoutParameters {
    return LayoutParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayoutParameters>, I>>(object: I): LayoutParameters {
    const message = createBaseLayoutParameters();
    message.zone_redundancy = (object.zone_redundancy !== undefined && object.zone_redundancy !== null)
      ? ZoneRedundancy.fromPartial(object.zone_redundancy)
      : undefined;
    return message;
  },
};

function createBaseZoneRedundancy(): ZoneRedundancy {
  return { fixed: undefined, maximum: undefined };
}

export const ZoneRedundancy: MessageFns<ZoneRedundancy> = {
  encode(message: ZoneRedundancy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fixed !== undefined) {
      writer.uint32(8).int32(message.fixed);
    }
    if (message.maximum !== undefined) {
      writer.uint32(16).bool(message.maximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZoneRedundancy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZoneRedundancy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fixed = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maximum = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZoneRedundancy {
    return {
      fixed: isSet(object.fixed) ? globalThis.Number(object.fixed) : undefined,
      maximum: isSet(object.maximum) ? globalThis.Boolean(object.maximum) : undefined,
    };
  },

  toJSON(message: ZoneRedundancy): unknown {
    const obj: any = {};
    if (message.fixed !== undefined) {
      obj.fixed = Math.round(message.fixed);
    }
    if (message.maximum !== undefined) {
      obj.maximum = message.maximum;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZoneRedundancy>, I>>(base?: I): ZoneRedundancy {
    return ZoneRedundancy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZoneRedundancy>, I>>(object: I): ZoneRedundancy {
    const message = createBaseZoneRedundancy();
    message.fixed = object.fixed ?? undefined;
    message.maximum = object.maximum ?? undefined;
    return message;
  },
};

function createBaseConnectNodeResult(): ConnectNodeResult {
  return { success: false, error: undefined };
}

export const ConnectNodeResult: MessageFns<ConnectNodeResult> = {
  encode(message: ConnectNodeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectNodeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectNodeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectNodeResult {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: ConnectNodeResult): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectNodeResult>, I>>(base?: I): ConnectNodeResult {
    return ConnectNodeResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectNodeResult>, I>>(object: I): ConnectNodeResult {
    const message = createBaseConnectNodeResult();
    message.success = object.success ?? false;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBasePartitionInfo(): PartitionInfo {
  return { partition: 0, nodes: [] };
}

export const PartitionInfo: MessageFns<PartitionInfo> = {
  encode(message: PartitionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partition !== 0) {
      writer.uint32(8).int32(message.partition);
    }
    for (const v of message.nodes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.partition = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionInfo {
    return {
      partition: isSet(object.partition) ? globalThis.Number(object.partition) : 0,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PartitionInfo): unknown {
    const obj: any = {};
    if (message.partition !== 0) {
      obj.partition = Math.round(message.partition);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartitionInfo>, I>>(base?: I): PartitionInfo {
    return PartitionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartitionInfo>, I>>(object: I): PartitionInfo {
    const message = createBasePartitionInfo();
    message.partition = object.partition ?? 0;
    message.nodes = object.nodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseLayoutVersion(): LayoutVersion {
  return { version: 0, update_time: "" };
}

export const LayoutVersion: MessageFns<LayoutVersion> = {
  encode(message: LayoutVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int64(message.version);
    }
    if (message.update_time !== "") {
      writer.uint32(18).string(message.update_time);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LayoutVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayoutVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.update_time = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LayoutVersion {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      update_time: isSet(object.updateTime)
        ? globalThis.String(object.updateTime)
        : isSet(object.update_time)
        ? globalThis.String(object.update_time)
        : "",
    };
  },

  toJSON(message: LayoutVersion): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.update_time !== "") {
      obj.updateTime = message.update_time;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LayoutVersion>, I>>(base?: I): LayoutVersion {
    return LayoutVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LayoutVersion>, I>>(object: I): LayoutVersion {
    const message = createBaseLayoutVersion();
    message.version = object.version ?? 0;
    message.update_time = object.update_time ?? "";
    return message;
  },
};

function createBaseUpdateTracker(): UpdateTracker {
  return { nodes: [] };
}

export const UpdateTracker: MessageFns<UpdateTracker> = {
  encode(message: UpdateTracker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      NodeUpdateProgress.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTracker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTracker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(NodeUpdateProgress.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTracker {
    return {
      nodes: globalThis.Array.isArray(object?.nodes)
        ? object.nodes.map((e: any) => NodeUpdateProgress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateTracker): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => NodeUpdateProgress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTracker>, I>>(base?: I): UpdateTracker {
    return UpdateTracker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTracker>, I>>(object: I): UpdateTracker {
    const message = createBaseUpdateTracker();
    message.nodes = object.nodes?.map((e) => NodeUpdateProgress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodeUpdateProgress(): NodeUpdateProgress {
  return { node_id: "", sync_version: undefined, write_version: undefined };
}

export const NodeUpdateProgress: MessageFns<NodeUpdateProgress> = {
  encode(message: NodeUpdateProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node_id !== "") {
      writer.uint32(10).string(message.node_id);
    }
    if (message.sync_version !== undefined) {
      writer.uint32(16).int64(message.sync_version);
    }
    if (message.write_version !== undefined) {
      writer.uint32(24).int64(message.write_version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeUpdateProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeUpdateProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sync_version = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.write_version = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeUpdateProgress {
    return {
      node_id: isSet(object.nodeId)
        ? globalThis.String(object.nodeId)
        : isSet(object.node_id)
        ? globalThis.String(object.node_id)
        : "",
      sync_version: isSet(object.syncVersion)
        ? globalThis.Number(object.syncVersion)
        : isSet(object.sync_version)
        ? globalThis.Number(object.sync_version)
        : undefined,
      write_version: isSet(object.writeVersion)
        ? globalThis.Number(object.writeVersion)
        : isSet(object.write_version)
        ? globalThis.Number(object.write_version)
        : undefined,
    };
  },

  toJSON(message: NodeUpdateProgress): unknown {
    const obj: any = {};
    if (message.node_id !== "") {
      obj.nodeId = message.node_id;
    }
    if (message.sync_version !== undefined) {
      obj.syncVersion = Math.round(message.sync_version);
    }
    if (message.write_version !== undefined) {
      obj.writeVersion = Math.round(message.write_version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeUpdateProgress>, I>>(base?: I): NodeUpdateProgress {
    return NodeUpdateProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeUpdateProgress>, I>>(object: I): NodeUpdateProgress {
    const message = createBaseNodeUpdateProgress();
    message.node_id = object.node_id ?? "";
    message.sync_version = object.sync_version ?? undefined;
    message.write_version = object.write_version ?? undefined;
    return message;
  },
};

/** Cluster Service - gRPC API for cluster management */
export interface ClusterService {
  /** Query operations */
  GetClusterStatus(request: GetClusterStatusRequest): Promise<ApiResponse>;
  GetClusterHealth(request: GetClusterHealthRequest): Promise<ApiResponse>;
  GetClusterLayout(request: GetClusterLayoutRequest): Promise<ApiResponse>;
  GetLayoutHistory(request: GetLayoutHistoryRequest): Promise<ApiResponse>;
  PreviewLayoutChanges(request: PreviewLayoutChangesRequest): Promise<ApiResponse>;
  /** Command operations */
  ConnectNodes(request: ConnectNodesRequest): Promise<ApiResponse>;
  UpdateLayout(request: UpdateLayoutRequest): Promise<ApiResponse>;
  ApplyLayout(request: ApplyLayoutRequest): Promise<ApiResponse>;
  RevertLayout(request: RevertLayoutRequest): Promise<ApiResponse>;
  SkipDeadNodes(request: SkipDeadNodesRequest): Promise<ApiResponse>;
}

export const ClusterServiceServiceName = "cluster.ClusterService";
export class ClusterServiceClientImpl implements ClusterService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ClusterServiceServiceName;
    this.rpc = rpc;
    this.GetClusterStatus = this.GetClusterStatus.bind(this);
    this.GetClusterHealth = this.GetClusterHealth.bind(this);
    this.GetClusterLayout = this.GetClusterLayout.bind(this);
    this.GetLayoutHistory = this.GetLayoutHistory.bind(this);
    this.PreviewLayoutChanges = this.PreviewLayoutChanges.bind(this);
    this.ConnectNodes = this.ConnectNodes.bind(this);
    this.UpdateLayout = this.UpdateLayout.bind(this);
    this.ApplyLayout = this.ApplyLayout.bind(this);
    this.RevertLayout = this.RevertLayout.bind(this);
    this.SkipDeadNodes = this.SkipDeadNodes.bind(this);
  }
  GetClusterStatus(request: GetClusterStatusRequest): Promise<ApiResponse> {
    const data = GetClusterStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetClusterStatus", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  GetClusterHealth(request: GetClusterHealthRequest): Promise<ApiResponse> {
    const data = GetClusterHealthRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetClusterHealth", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  GetClusterLayout(request: GetClusterLayoutRequest): Promise<ApiResponse> {
    const data = GetClusterLayoutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetClusterLayout", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  GetLayoutHistory(request: GetLayoutHistoryRequest): Promise<ApiResponse> {
    const data = GetLayoutHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLayoutHistory", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  PreviewLayoutChanges(request: PreviewLayoutChangesRequest): Promise<ApiResponse> {
    const data = PreviewLayoutChangesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PreviewLayoutChanges", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  ConnectNodes(request: ConnectNodesRequest): Promise<ApiResponse> {
    const data = ConnectNodesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ConnectNodes", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  UpdateLayout(request: UpdateLayoutRequest): Promise<ApiResponse> {
    const data = UpdateLayoutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateLayout", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  ApplyLayout(request: ApplyLayoutRequest): Promise<ApiResponse> {
    const data = ApplyLayoutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApplyLayout", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  RevertLayout(request: RevertLayoutRequest): Promise<ApiResponse> {
    const data = RevertLayoutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevertLayout", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  SkipDeadNodes(request: SkipDeadNodesRequest): Promise<ApiResponse> {
    const data = SkipDeadNodesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SkipDeadNodes", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
