// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v5.29.3
// source: block.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "block";

/** Unified API response with trace_id */
export interface ApiResponse {
  trace_id: string;
  block_info?: MultiNodeBlockInfoData | undefined;
  block_errors?: MultiNodeBlockErrorsData | undefined;
  purge_result?: MultiNodePurgeResultData | undefined;
  resync_result?: MultiNodeResyncResultData | undefined;
}

export interface MultiNodeBlockInfoData {
  results: { [key: string]: BlockInfoResult };
}

export interface MultiNodeBlockInfoData_ResultsEntry {
  key: string;
  value: BlockInfoResult | undefined;
}

export interface MultiNodeBlockErrorsData {
  results: { [key: string]: BlockErrorsResult };
}

export interface MultiNodeBlockErrorsData_ResultsEntry {
  key: string;
  value: BlockErrorsResult | undefined;
}

export interface MultiNodePurgeResultData {
  results: { [key: string]: PurgeResult };
}

export interface MultiNodePurgeResultData_ResultsEntry {
  key: string;
  value: PurgeResult | undefined;
}

export interface MultiNodeResyncResultData {
  results: { [key: string]: ResyncResult };
}

export interface MultiNodeResyncResultData_ResultsEntry {
  key: string;
  value: ResyncResult | undefined;
}

export interface GetBlockInfoRequest {
  /** Node ID or "*" for all nodes */
  node: string;
  block_hash: string;
}

export interface ListBlockErrorsRequest {
  /** Node ID or "*" for all nodes */
  node: string;
}

export interface PurgeBlocksRequest {
  /** Node ID or "*" for all nodes */
  node: string;
  block_hashes: string[];
}

export interface RetryBlockResyncRequest {
  /** Node ID or "*" for all nodes */
  node: string;
  /** Empty = retry all */
  block_hashes: string[];
  /** If true, retry all blocks */
  all: boolean;
}

export interface BlockInfoResult {
  info?: BlockInfo | undefined;
  error?: string | undefined;
}

export interface BlockInfo {
  block_hash: string;
  size: number;
  refcount: number;
  versions: BlockVersionRef[];
  uploads: BlockUploadRef[];
}

export interface BlockVersionRef {
  bucket_id: string;
  key: string;
  version_uuid: string;
  deleted: boolean;
  block_offset: number;
}

export interface BlockUploadRef {
  bucket_id: string;
  key: string;
  upload_id: string;
  part_number: number;
  block_offset: number;
}

export interface BlockErrorsResult {
  errors?: BlockErrors | undefined;
  error?: string | undefined;
}

export interface BlockErrors {
  errors: BlockError[];
}

export interface BlockError {
  block_hash: string;
  error: string;
}

export interface PurgeResult {
  purge_result?: PurgeBlocksResult | undefined;
  error?: string | undefined;
}

export interface PurgeBlocksResult {
  blocks_purged: number;
  objects_deleted: number;
  uploads_deleted: number;
}

export interface ResyncResult {
  resync_result?: RetryResyncResult | undefined;
  error?: string | undefined;
}

export interface RetryResyncResult {
  blocks_retried: number;
}

function createBaseApiResponse(): ApiResponse {
  return {
    trace_id: "",
    block_info: undefined,
    block_errors: undefined,
    purge_result: undefined,
    resync_result: undefined,
  };
}

export const ApiResponse: MessageFns<ApiResponse> = {
  encode(message: ApiResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trace_id !== "") {
      writer.uint32(10).string(message.trace_id);
    }
    if (message.block_info !== undefined) {
      MultiNodeBlockInfoData.encode(message.block_info, writer.uint32(18).fork()).join();
    }
    if (message.block_errors !== undefined) {
      MultiNodeBlockErrorsData.encode(message.block_errors, writer.uint32(26).fork()).join();
    }
    if (message.purge_result !== undefined) {
      MultiNodePurgeResultData.encode(message.purge_result, writer.uint32(34).fork()).join();
    }
    if (message.resync_result !== undefined) {
      MultiNodeResyncResultData.encode(message.resync_result, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.block_info = MultiNodeBlockInfoData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.block_errors = MultiNodeBlockErrorsData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.purge_result = MultiNodePurgeResultData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resync_result = MultiNodeResyncResultData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiResponse {
    return {
      trace_id: isSet(object.traceId)
        ? globalThis.String(object.traceId)
        : isSet(object.trace_id)
        ? globalThis.String(object.trace_id)
        : "",
      block_info: isSet(object.blockInfo)
        ? MultiNodeBlockInfoData.fromJSON(object.blockInfo)
        : isSet(object.block_info)
        ? MultiNodeBlockInfoData.fromJSON(object.block_info)
        : undefined,
      block_errors: isSet(object.blockErrors)
        ? MultiNodeBlockErrorsData.fromJSON(object.blockErrors)
        : isSet(object.block_errors)
        ? MultiNodeBlockErrorsData.fromJSON(object.block_errors)
        : undefined,
      purge_result: isSet(object.purgeResult)
        ? MultiNodePurgeResultData.fromJSON(object.purgeResult)
        : isSet(object.purge_result)
        ? MultiNodePurgeResultData.fromJSON(object.purge_result)
        : undefined,
      resync_result: isSet(object.resyncResult)
        ? MultiNodeResyncResultData.fromJSON(object.resyncResult)
        : isSet(object.resync_result)
        ? MultiNodeResyncResultData.fromJSON(object.resync_result)
        : undefined,
    };
  },

  toJSON(message: ApiResponse): unknown {
    const obj: any = {};
    if (message.trace_id !== "") {
      obj.traceId = message.trace_id;
    }
    if (message.block_info !== undefined) {
      obj.blockInfo = MultiNodeBlockInfoData.toJSON(message.block_info);
    }
    if (message.block_errors !== undefined) {
      obj.blockErrors = MultiNodeBlockErrorsData.toJSON(message.block_errors);
    }
    if (message.purge_result !== undefined) {
      obj.purgeResult = MultiNodePurgeResultData.toJSON(message.purge_result);
    }
    if (message.resync_result !== undefined) {
      obj.resyncResult = MultiNodeResyncResultData.toJSON(message.resync_result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApiResponse>, I>>(base?: I): ApiResponse {
    return ApiResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApiResponse>, I>>(object: I): ApiResponse {
    const message = createBaseApiResponse();
    message.trace_id = object.trace_id ?? "";
    message.block_info = (object.block_info !== undefined && object.block_info !== null)
      ? MultiNodeBlockInfoData.fromPartial(object.block_info)
      : undefined;
    message.block_errors = (object.block_errors !== undefined && object.block_errors !== null)
      ? MultiNodeBlockErrorsData.fromPartial(object.block_errors)
      : undefined;
    message.purge_result = (object.purge_result !== undefined && object.purge_result !== null)
      ? MultiNodePurgeResultData.fromPartial(object.purge_result)
      : undefined;
    message.resync_result = (object.resync_result !== undefined && object.resync_result !== null)
      ? MultiNodeResyncResultData.fromPartial(object.resync_result)
      : undefined;
    return message;
  },
};

function createBaseMultiNodeBlockInfoData(): MultiNodeBlockInfoData {
  return { results: {} };
}

export const MultiNodeBlockInfoData: MessageFns<MultiNodeBlockInfoData> = {
  encode(message: MultiNodeBlockInfoData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.results).forEach(([key, value]: [string, BlockInfoResult]) => {
      MultiNodeBlockInfoData_ResultsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodeBlockInfoData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodeBlockInfoData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MultiNodeBlockInfoData_ResultsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.results[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodeBlockInfoData {
    return {
      results: isObject(object.results)
        ? (globalThis.Object.entries(object.results) as [string, any][]).reduce(
          (acc: { [key: string]: BlockInfoResult }, [key, value]: [string, any]) => {
            acc[key] = BlockInfoResult.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: MultiNodeBlockInfoData): unknown {
    const obj: any = {};
    if (message.results) {
      const entries = globalThis.Object.entries(message.results) as [string, BlockInfoResult][];
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = BlockInfoResult.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodeBlockInfoData>, I>>(base?: I): MultiNodeBlockInfoData {
    return MultiNodeBlockInfoData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodeBlockInfoData>, I>>(object: I): MultiNodeBlockInfoData {
    const message = createBaseMultiNodeBlockInfoData();
    message.results = (globalThis.Object.entries(object.results ?? {}) as [string, BlockInfoResult][]).reduce(
      (acc: { [key: string]: BlockInfoResult }, [key, value]: [string, BlockInfoResult]) => {
        if (value !== undefined) {
          acc[key] = BlockInfoResult.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMultiNodeBlockInfoData_ResultsEntry(): MultiNodeBlockInfoData_ResultsEntry {
  return { key: "", value: undefined };
}

export const MultiNodeBlockInfoData_ResultsEntry: MessageFns<MultiNodeBlockInfoData_ResultsEntry> = {
  encode(message: MultiNodeBlockInfoData_ResultsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      BlockInfoResult.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodeBlockInfoData_ResultsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodeBlockInfoData_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BlockInfoResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodeBlockInfoData_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? BlockInfoResult.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MultiNodeBlockInfoData_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = BlockInfoResult.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodeBlockInfoData_ResultsEntry>, I>>(
    base?: I,
  ): MultiNodeBlockInfoData_ResultsEntry {
    return MultiNodeBlockInfoData_ResultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodeBlockInfoData_ResultsEntry>, I>>(
    object: I,
  ): MultiNodeBlockInfoData_ResultsEntry {
    const message = createBaseMultiNodeBlockInfoData_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? BlockInfoResult.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMultiNodeBlockErrorsData(): MultiNodeBlockErrorsData {
  return { results: {} };
}

export const MultiNodeBlockErrorsData: MessageFns<MultiNodeBlockErrorsData> = {
  encode(message: MultiNodeBlockErrorsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.results).forEach(([key, value]: [string, BlockErrorsResult]) => {
      MultiNodeBlockErrorsData_ResultsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodeBlockErrorsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodeBlockErrorsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MultiNodeBlockErrorsData_ResultsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.results[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodeBlockErrorsData {
    return {
      results: isObject(object.results)
        ? (globalThis.Object.entries(object.results) as [string, any][]).reduce(
          (acc: { [key: string]: BlockErrorsResult }, [key, value]: [string, any]) => {
            acc[key] = BlockErrorsResult.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: MultiNodeBlockErrorsData): unknown {
    const obj: any = {};
    if (message.results) {
      const entries = globalThis.Object.entries(message.results) as [string, BlockErrorsResult][];
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = BlockErrorsResult.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodeBlockErrorsData>, I>>(base?: I): MultiNodeBlockErrorsData {
    return MultiNodeBlockErrorsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodeBlockErrorsData>, I>>(object: I): MultiNodeBlockErrorsData {
    const message = createBaseMultiNodeBlockErrorsData();
    message.results = (globalThis.Object.entries(object.results ?? {}) as [string, BlockErrorsResult][]).reduce(
      (acc: { [key: string]: BlockErrorsResult }, [key, value]: [string, BlockErrorsResult]) => {
        if (value !== undefined) {
          acc[key] = BlockErrorsResult.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMultiNodeBlockErrorsData_ResultsEntry(): MultiNodeBlockErrorsData_ResultsEntry {
  return { key: "", value: undefined };
}

export const MultiNodeBlockErrorsData_ResultsEntry: MessageFns<MultiNodeBlockErrorsData_ResultsEntry> = {
  encode(message: MultiNodeBlockErrorsData_ResultsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      BlockErrorsResult.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodeBlockErrorsData_ResultsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodeBlockErrorsData_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BlockErrorsResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodeBlockErrorsData_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? BlockErrorsResult.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MultiNodeBlockErrorsData_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = BlockErrorsResult.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodeBlockErrorsData_ResultsEntry>, I>>(
    base?: I,
  ): MultiNodeBlockErrorsData_ResultsEntry {
    return MultiNodeBlockErrorsData_ResultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodeBlockErrorsData_ResultsEntry>, I>>(
    object: I,
  ): MultiNodeBlockErrorsData_ResultsEntry {
    const message = createBaseMultiNodeBlockErrorsData_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? BlockErrorsResult.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMultiNodePurgeResultData(): MultiNodePurgeResultData {
  return { results: {} };
}

export const MultiNodePurgeResultData: MessageFns<MultiNodePurgeResultData> = {
  encode(message: MultiNodePurgeResultData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.results).forEach(([key, value]: [string, PurgeResult]) => {
      MultiNodePurgeResultData_ResultsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodePurgeResultData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodePurgeResultData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MultiNodePurgeResultData_ResultsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.results[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodePurgeResultData {
    return {
      results: isObject(object.results)
        ? (globalThis.Object.entries(object.results) as [string, any][]).reduce(
          (acc: { [key: string]: PurgeResult }, [key, value]: [string, any]) => {
            acc[key] = PurgeResult.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: MultiNodePurgeResultData): unknown {
    const obj: any = {};
    if (message.results) {
      const entries = globalThis.Object.entries(message.results) as [string, PurgeResult][];
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = PurgeResult.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodePurgeResultData>, I>>(base?: I): MultiNodePurgeResultData {
    return MultiNodePurgeResultData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodePurgeResultData>, I>>(object: I): MultiNodePurgeResultData {
    const message = createBaseMultiNodePurgeResultData();
    message.results = (globalThis.Object.entries(object.results ?? {}) as [string, PurgeResult][]).reduce(
      (acc: { [key: string]: PurgeResult }, [key, value]: [string, PurgeResult]) => {
        if (value !== undefined) {
          acc[key] = PurgeResult.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMultiNodePurgeResultData_ResultsEntry(): MultiNodePurgeResultData_ResultsEntry {
  return { key: "", value: undefined };
}

export const MultiNodePurgeResultData_ResultsEntry: MessageFns<MultiNodePurgeResultData_ResultsEntry> = {
  encode(message: MultiNodePurgeResultData_ResultsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PurgeResult.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodePurgeResultData_ResultsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodePurgeResultData_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = PurgeResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodePurgeResultData_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? PurgeResult.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MultiNodePurgeResultData_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = PurgeResult.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodePurgeResultData_ResultsEntry>, I>>(
    base?: I,
  ): MultiNodePurgeResultData_ResultsEntry {
    return MultiNodePurgeResultData_ResultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodePurgeResultData_ResultsEntry>, I>>(
    object: I,
  ): MultiNodePurgeResultData_ResultsEntry {
    const message = createBaseMultiNodePurgeResultData_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PurgeResult.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMultiNodeResyncResultData(): MultiNodeResyncResultData {
  return { results: {} };
}

export const MultiNodeResyncResultData: MessageFns<MultiNodeResyncResultData> = {
  encode(message: MultiNodeResyncResultData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.results).forEach(([key, value]: [string, ResyncResult]) => {
      MultiNodeResyncResultData_ResultsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodeResyncResultData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodeResyncResultData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MultiNodeResyncResultData_ResultsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.results[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodeResyncResultData {
    return {
      results: isObject(object.results)
        ? (globalThis.Object.entries(object.results) as [string, any][]).reduce(
          (acc: { [key: string]: ResyncResult }, [key, value]: [string, any]) => {
            acc[key] = ResyncResult.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: MultiNodeResyncResultData): unknown {
    const obj: any = {};
    if (message.results) {
      const entries = globalThis.Object.entries(message.results) as [string, ResyncResult][];
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = ResyncResult.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodeResyncResultData>, I>>(base?: I): MultiNodeResyncResultData {
    return MultiNodeResyncResultData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodeResyncResultData>, I>>(object: I): MultiNodeResyncResultData {
    const message = createBaseMultiNodeResyncResultData();
    message.results = (globalThis.Object.entries(object.results ?? {}) as [string, ResyncResult][]).reduce(
      (acc: { [key: string]: ResyncResult }, [key, value]: [string, ResyncResult]) => {
        if (value !== undefined) {
          acc[key] = ResyncResult.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMultiNodeResyncResultData_ResultsEntry(): MultiNodeResyncResultData_ResultsEntry {
  return { key: "", value: undefined };
}

export const MultiNodeResyncResultData_ResultsEntry: MessageFns<MultiNodeResyncResultData_ResultsEntry> = {
  encode(message: MultiNodeResyncResultData_ResultsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ResyncResult.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiNodeResyncResultData_ResultsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiNodeResyncResultData_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ResyncResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiNodeResyncResultData_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ResyncResult.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MultiNodeResyncResultData_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ResyncResult.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiNodeResyncResultData_ResultsEntry>, I>>(
    base?: I,
  ): MultiNodeResyncResultData_ResultsEntry {
    return MultiNodeResyncResultData_ResultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiNodeResyncResultData_ResultsEntry>, I>>(
    object: I,
  ): MultiNodeResyncResultData_ResultsEntry {
    const message = createBaseMultiNodeResyncResultData_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ResyncResult.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetBlockInfoRequest(): GetBlockInfoRequest {
  return { node: "", block_hash: "" };
}

export const GetBlockInfoRequest: MessageFns<GetBlockInfoRequest> = {
  encode(message: GetBlockInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    if (message.block_hash !== "") {
      writer.uint32(18).string(message.block_hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.block_hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockInfoRequest {
    return {
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      block_hash: isSet(object.blockHash)
        ? globalThis.String(object.blockHash)
        : isSet(object.block_hash)
        ? globalThis.String(object.block_hash)
        : "",
    };
  },

  toJSON(message: GetBlockInfoRequest): unknown {
    const obj: any = {};
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.block_hash !== "") {
      obj.blockHash = message.block_hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBlockInfoRequest>, I>>(base?: I): GetBlockInfoRequest {
    return GetBlockInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBlockInfoRequest>, I>>(object: I): GetBlockInfoRequest {
    const message = createBaseGetBlockInfoRequest();
    message.node = object.node ?? "";
    message.block_hash = object.block_hash ?? "";
    return message;
  },
};

function createBaseListBlockErrorsRequest(): ListBlockErrorsRequest {
  return { node: "" };
}

export const ListBlockErrorsRequest: MessageFns<ListBlockErrorsRequest> = {
  encode(message: ListBlockErrorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBlockErrorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlockErrorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlockErrorsRequest {
    return { node: isSet(object.node) ? globalThis.String(object.node) : "" };
  },

  toJSON(message: ListBlockErrorsRequest): unknown {
    const obj: any = {};
    if (message.node !== "") {
      obj.node = message.node;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBlockErrorsRequest>, I>>(base?: I): ListBlockErrorsRequest {
    return ListBlockErrorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBlockErrorsRequest>, I>>(object: I): ListBlockErrorsRequest {
    const message = createBaseListBlockErrorsRequest();
    message.node = object.node ?? "";
    return message;
  },
};

function createBasePurgeBlocksRequest(): PurgeBlocksRequest {
  return { node: "", block_hashes: [] };
}

export const PurgeBlocksRequest: MessageFns<PurgeBlocksRequest> = {
  encode(message: PurgeBlocksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    for (const v of message.block_hashes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeBlocksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeBlocksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.block_hashes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeBlocksRequest {
    return {
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      block_hashes: globalThis.Array.isArray(object?.blockHashes)
        ? object.blockHashes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.block_hashes)
        ? object.block_hashes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PurgeBlocksRequest): unknown {
    const obj: any = {};
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.block_hashes?.length) {
      obj.blockHashes = message.block_hashes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurgeBlocksRequest>, I>>(base?: I): PurgeBlocksRequest {
    return PurgeBlocksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurgeBlocksRequest>, I>>(object: I): PurgeBlocksRequest {
    const message = createBasePurgeBlocksRequest();
    message.node = object.node ?? "";
    message.block_hashes = object.block_hashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseRetryBlockResyncRequest(): RetryBlockResyncRequest {
  return { node: "", block_hashes: [], all: false };
}

export const RetryBlockResyncRequest: MessageFns<RetryBlockResyncRequest> = {
  encode(message: RetryBlockResyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    for (const v of message.block_hashes) {
      writer.uint32(18).string(v!);
    }
    if (message.all !== false) {
      writer.uint32(24).bool(message.all);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryBlockResyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryBlockResyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.node = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.block_hashes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.all = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryBlockResyncRequest {
    return {
      node: isSet(object.node) ? globalThis.String(object.node) : "",
      block_hashes: globalThis.Array.isArray(object?.blockHashes)
        ? object.blockHashes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.block_hashes)
        ? object.block_hashes.map((e: any) => globalThis.String(e))
        : [],
      all: isSet(object.all) ? globalThis.Boolean(object.all) : false,
    };
  },

  toJSON(message: RetryBlockResyncRequest): unknown {
    const obj: any = {};
    if (message.node !== "") {
      obj.node = message.node;
    }
    if (message.block_hashes?.length) {
      obj.blockHashes = message.block_hashes;
    }
    if (message.all !== false) {
      obj.all = message.all;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryBlockResyncRequest>, I>>(base?: I): RetryBlockResyncRequest {
    return RetryBlockResyncRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryBlockResyncRequest>, I>>(object: I): RetryBlockResyncRequest {
    const message = createBaseRetryBlockResyncRequest();
    message.node = object.node ?? "";
    message.block_hashes = object.block_hashes?.map((e) => e) || [];
    message.all = object.all ?? false;
    return message;
  },
};

function createBaseBlockInfoResult(): BlockInfoResult {
  return { info: undefined, error: undefined };
}

export const BlockInfoResult: MessageFns<BlockInfoResult> = {
  encode(message: BlockInfoResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      BlockInfo.encode(message.info, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockInfoResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockInfoResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.info = BlockInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockInfoResult {
    return {
      info: isSet(object.info) ? BlockInfo.fromJSON(object.info) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: BlockInfoResult): unknown {
    const obj: any = {};
    if (message.info !== undefined) {
      obj.info = BlockInfo.toJSON(message.info);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockInfoResult>, I>>(base?: I): BlockInfoResult {
    return BlockInfoResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockInfoResult>, I>>(object: I): BlockInfoResult {
    const message = createBaseBlockInfoResult();
    message.info = (object.info !== undefined && object.info !== null) ? BlockInfo.fromPartial(object.info) : undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseBlockInfo(): BlockInfo {
  return { block_hash: "", size: 0, refcount: 0, versions: [], uploads: [] };
}

export const BlockInfo: MessageFns<BlockInfo> = {
  encode(message: BlockInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block_hash !== "") {
      writer.uint32(10).string(message.block_hash);
    }
    if (message.size !== 0) {
      writer.uint32(16).int64(message.size);
    }
    if (message.refcount !== 0) {
      writer.uint32(24).int64(message.refcount);
    }
    for (const v of message.versions) {
      BlockVersionRef.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.uploads) {
      BlockUploadRef.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block_hash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.refcount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.versions.push(BlockVersionRef.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.uploads.push(BlockUploadRef.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockInfo {
    return {
      block_hash: isSet(object.blockHash)
        ? globalThis.String(object.blockHash)
        : isSet(object.block_hash)
        ? globalThis.String(object.block_hash)
        : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      refcount: isSet(object.refcount) ? globalThis.Number(object.refcount) : 0,
      versions: globalThis.Array.isArray(object?.versions)
        ? object.versions.map((e: any) => BlockVersionRef.fromJSON(e))
        : [],
      uploads: globalThis.Array.isArray(object?.uploads)
        ? object.uploads.map((e: any) => BlockUploadRef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BlockInfo): unknown {
    const obj: any = {};
    if (message.block_hash !== "") {
      obj.blockHash = message.block_hash;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.refcount !== 0) {
      obj.refcount = Math.round(message.refcount);
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => BlockVersionRef.toJSON(e));
    }
    if (message.uploads?.length) {
      obj.uploads = message.uploads.map((e) => BlockUploadRef.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockInfo>, I>>(base?: I): BlockInfo {
    return BlockInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockInfo>, I>>(object: I): BlockInfo {
    const message = createBaseBlockInfo();
    message.block_hash = object.block_hash ?? "";
    message.size = object.size ?? 0;
    message.refcount = object.refcount ?? 0;
    message.versions = object.versions?.map((e) => BlockVersionRef.fromPartial(e)) || [];
    message.uploads = object.uploads?.map((e) => BlockUploadRef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockVersionRef(): BlockVersionRef {
  return { bucket_id: "", key: "", version_uuid: "", deleted: false, block_offset: 0 };
}

export const BlockVersionRef: MessageFns<BlockVersionRef> = {
  encode(message: BlockVersionRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket_id !== "") {
      writer.uint32(10).string(message.bucket_id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.version_uuid !== "") {
      writer.uint32(26).string(message.version_uuid);
    }
    if (message.deleted !== false) {
      writer.uint32(32).bool(message.deleted);
    }
    if (message.block_offset !== 0) {
      writer.uint32(40).int64(message.block_offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockVersionRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockVersionRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version_uuid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.block_offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockVersionRef {
    return {
      bucket_id: isSet(object.bucketId)
        ? globalThis.String(object.bucketId)
        : isSet(object.bucket_id)
        ? globalThis.String(object.bucket_id)
        : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      version_uuid: isSet(object.versionUuid)
        ? globalThis.String(object.versionUuid)
        : isSet(object.version_uuid)
        ? globalThis.String(object.version_uuid)
        : "",
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      block_offset: isSet(object.blockOffset)
        ? globalThis.Number(object.blockOffset)
        : isSet(object.block_offset)
        ? globalThis.Number(object.block_offset)
        : 0,
    };
  },

  toJSON(message: BlockVersionRef): unknown {
    const obj: any = {};
    if (message.bucket_id !== "") {
      obj.bucketId = message.bucket_id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.version_uuid !== "") {
      obj.versionUuid = message.version_uuid;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.block_offset !== 0) {
      obj.blockOffset = Math.round(message.block_offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockVersionRef>, I>>(base?: I): BlockVersionRef {
    return BlockVersionRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockVersionRef>, I>>(object: I): BlockVersionRef {
    const message = createBaseBlockVersionRef();
    message.bucket_id = object.bucket_id ?? "";
    message.key = object.key ?? "";
    message.version_uuid = object.version_uuid ?? "";
    message.deleted = object.deleted ?? false;
    message.block_offset = object.block_offset ?? 0;
    return message;
  },
};

function createBaseBlockUploadRef(): BlockUploadRef {
  return { bucket_id: "", key: "", upload_id: "", part_number: 0, block_offset: 0 };
}

export const BlockUploadRef: MessageFns<BlockUploadRef> = {
  encode(message: BlockUploadRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket_id !== "") {
      writer.uint32(10).string(message.bucket_id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.upload_id !== "") {
      writer.uint32(26).string(message.upload_id);
    }
    if (message.part_number !== 0) {
      writer.uint32(32).int32(message.part_number);
    }
    if (message.block_offset !== 0) {
      writer.uint32(40).int64(message.block_offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUploadRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUploadRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucket_id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upload_id = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.part_number = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.block_offset = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUploadRef {
    return {
      bucket_id: isSet(object.bucketId)
        ? globalThis.String(object.bucketId)
        : isSet(object.bucket_id)
        ? globalThis.String(object.bucket_id)
        : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      upload_id: isSet(object.uploadId)
        ? globalThis.String(object.uploadId)
        : isSet(object.upload_id)
        ? globalThis.String(object.upload_id)
        : "",
      part_number: isSet(object.partNumber)
        ? globalThis.Number(object.partNumber)
        : isSet(object.part_number)
        ? globalThis.Number(object.part_number)
        : 0,
      block_offset: isSet(object.blockOffset)
        ? globalThis.Number(object.blockOffset)
        : isSet(object.block_offset)
        ? globalThis.Number(object.block_offset)
        : 0,
    };
  },

  toJSON(message: BlockUploadRef): unknown {
    const obj: any = {};
    if (message.bucket_id !== "") {
      obj.bucketId = message.bucket_id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.upload_id !== "") {
      obj.uploadId = message.upload_id;
    }
    if (message.part_number !== 0) {
      obj.partNumber = Math.round(message.part_number);
    }
    if (message.block_offset !== 0) {
      obj.blockOffset = Math.round(message.block_offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUploadRef>, I>>(base?: I): BlockUploadRef {
    return BlockUploadRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUploadRef>, I>>(object: I): BlockUploadRef {
    const message = createBaseBlockUploadRef();
    message.bucket_id = object.bucket_id ?? "";
    message.key = object.key ?? "";
    message.upload_id = object.upload_id ?? "";
    message.part_number = object.part_number ?? 0;
    message.block_offset = object.block_offset ?? 0;
    return message;
  },
};

function createBaseBlockErrorsResult(): BlockErrorsResult {
  return { errors: undefined, error: undefined };
}

export const BlockErrorsResult: MessageFns<BlockErrorsResult> = {
  encode(message: BlockErrorsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errors !== undefined) {
      BlockErrors.encode(message.errors, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockErrorsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockErrorsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors = BlockErrors.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockErrorsResult {
    return {
      errors: isSet(object.errors) ? BlockErrors.fromJSON(object.errors) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: BlockErrorsResult): unknown {
    const obj: any = {};
    if (message.errors !== undefined) {
      obj.errors = BlockErrors.toJSON(message.errors);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockErrorsResult>, I>>(base?: I): BlockErrorsResult {
    return BlockErrorsResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockErrorsResult>, I>>(object: I): BlockErrorsResult {
    const message = createBaseBlockErrorsResult();
    message.errors = (object.errors !== undefined && object.errors !== null)
      ? BlockErrors.fromPartial(object.errors)
      : undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseBlockErrors(): BlockErrors {
  return { errors: [] };
}

export const BlockErrors: MessageFns<BlockErrors> = {
  encode(message: BlockErrors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      BlockError.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockErrors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockErrors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(BlockError.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockErrors {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => BlockError.fromJSON(e)) : [],
    };
  },

  toJSON(message: BlockErrors): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => BlockError.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockErrors>, I>>(base?: I): BlockErrors {
    return BlockErrors.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockErrors>, I>>(object: I): BlockErrors {
    const message = createBaseBlockErrors();
    message.errors = object.errors?.map((e) => BlockError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockError(): BlockError {
  return { block_hash: "", error: "" };
}

export const BlockError: MessageFns<BlockError> = {
  encode(message: BlockError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.block_hash !== "") {
      writer.uint32(10).string(message.block_hash);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.block_hash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockError {
    return {
      block_hash: isSet(object.blockHash)
        ? globalThis.String(object.blockHash)
        : isSet(object.block_hash)
        ? globalThis.String(object.block_hash)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BlockError): unknown {
    const obj: any = {};
    if (message.block_hash !== "") {
      obj.blockHash = message.block_hash;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockError>, I>>(base?: I): BlockError {
    return BlockError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockError>, I>>(object: I): BlockError {
    const message = createBaseBlockError();
    message.block_hash = object.block_hash ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBasePurgeResult(): PurgeResult {
  return { purge_result: undefined, error: undefined };
}

export const PurgeResult: MessageFns<PurgeResult> = {
  encode(message: PurgeResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purge_result !== undefined) {
      PurgeBlocksResult.encode(message.purge_result, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purge_result = PurgeBlocksResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeResult {
    return {
      purge_result: isSet(object.purgeResult)
        ? PurgeBlocksResult.fromJSON(object.purgeResult)
        : isSet(object.purge_result)
        ? PurgeBlocksResult.fromJSON(object.purge_result)
        : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: PurgeResult): unknown {
    const obj: any = {};
    if (message.purge_result !== undefined) {
      obj.purgeResult = PurgeBlocksResult.toJSON(message.purge_result);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurgeResult>, I>>(base?: I): PurgeResult {
    return PurgeResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurgeResult>, I>>(object: I): PurgeResult {
    const message = createBasePurgeResult();
    message.purge_result = (object.purge_result !== undefined && object.purge_result !== null)
      ? PurgeBlocksResult.fromPartial(object.purge_result)
      : undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBasePurgeBlocksResult(): PurgeBlocksResult {
  return { blocks_purged: 0, objects_deleted: 0, uploads_deleted: 0 };
}

export const PurgeBlocksResult: MessageFns<PurgeBlocksResult> = {
  encode(message: PurgeBlocksResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blocks_purged !== 0) {
      writer.uint32(8).int64(message.blocks_purged);
    }
    if (message.objects_deleted !== 0) {
      writer.uint32(16).int64(message.objects_deleted);
    }
    if (message.uploads_deleted !== 0) {
      writer.uint32(24).int64(message.uploads_deleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeBlocksResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeBlocksResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blocks_purged = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.objects_deleted = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uploads_deleted = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeBlocksResult {
    return {
      blocks_purged: isSet(object.blocksPurged)
        ? globalThis.Number(object.blocksPurged)
        : isSet(object.blocks_purged)
        ? globalThis.Number(object.blocks_purged)
        : 0,
      objects_deleted: isSet(object.objectsDeleted)
        ? globalThis.Number(object.objectsDeleted)
        : isSet(object.objects_deleted)
        ? globalThis.Number(object.objects_deleted)
        : 0,
      uploads_deleted: isSet(object.uploadsDeleted)
        ? globalThis.Number(object.uploadsDeleted)
        : isSet(object.uploads_deleted)
        ? globalThis.Number(object.uploads_deleted)
        : 0,
    };
  },

  toJSON(message: PurgeBlocksResult): unknown {
    const obj: any = {};
    if (message.blocks_purged !== 0) {
      obj.blocksPurged = Math.round(message.blocks_purged);
    }
    if (message.objects_deleted !== 0) {
      obj.objectsDeleted = Math.round(message.objects_deleted);
    }
    if (message.uploads_deleted !== 0) {
      obj.uploadsDeleted = Math.round(message.uploads_deleted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurgeBlocksResult>, I>>(base?: I): PurgeBlocksResult {
    return PurgeBlocksResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurgeBlocksResult>, I>>(object: I): PurgeBlocksResult {
    const message = createBasePurgeBlocksResult();
    message.blocks_purged = object.blocks_purged ?? 0;
    message.objects_deleted = object.objects_deleted ?? 0;
    message.uploads_deleted = object.uploads_deleted ?? 0;
    return message;
  },
};

function createBaseResyncResult(): ResyncResult {
  return { resync_result: undefined, error: undefined };
}

export const ResyncResult: MessageFns<ResyncResult> = {
  encode(message: ResyncResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resync_result !== undefined) {
      RetryResyncResult.encode(message.resync_result, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResyncResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResyncResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resync_result = RetryResyncResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResyncResult {
    return {
      resync_result: isSet(object.resyncResult)
        ? RetryResyncResult.fromJSON(object.resyncResult)
        : isSet(object.resync_result)
        ? RetryResyncResult.fromJSON(object.resync_result)
        : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: ResyncResult): unknown {
    const obj: any = {};
    if (message.resync_result !== undefined) {
      obj.resyncResult = RetryResyncResult.toJSON(message.resync_result);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResyncResult>, I>>(base?: I): ResyncResult {
    return ResyncResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResyncResult>, I>>(object: I): ResyncResult {
    const message = createBaseResyncResult();
    message.resync_result = (object.resync_result !== undefined && object.resync_result !== null)
      ? RetryResyncResult.fromPartial(object.resync_result)
      : undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseRetryResyncResult(): RetryResyncResult {
  return { blocks_retried: 0 };
}

export const RetryResyncResult: MessageFns<RetryResyncResult> = {
  encode(message: RetryResyncResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blocks_retried !== 0) {
      writer.uint32(8).int64(message.blocks_retried);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryResyncResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryResyncResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blocks_retried = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryResyncResult {
    return {
      blocks_retried: isSet(object.blocksRetried)
        ? globalThis.Number(object.blocksRetried)
        : isSet(object.blocks_retried)
        ? globalThis.Number(object.blocks_retried)
        : 0,
    };
  },

  toJSON(message: RetryResyncResult): unknown {
    const obj: any = {};
    if (message.blocks_retried !== 0) {
      obj.blocksRetried = Math.round(message.blocks_retried);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryResyncResult>, I>>(base?: I): RetryResyncResult {
    return RetryResyncResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryResyncResult>, I>>(object: I): RetryResyncResult {
    const message = createBaseRetryResyncResult();
    message.blocks_retried = object.blocks_retried ?? 0;
    return message;
  },
};

/** Block Service - gRPC API for block operations */
export interface BlockService {
  /** Query operations */
  GetBlockInfo(request: GetBlockInfoRequest): Promise<ApiResponse>;
  ListBlockErrors(request: ListBlockErrorsRequest): Promise<ApiResponse>;
  /** Command operations */
  PurgeBlocks(request: PurgeBlocksRequest): Promise<ApiResponse>;
  RetryBlockResync(request: RetryBlockResyncRequest): Promise<ApiResponse>;
}

export const BlockServiceServiceName = "block.BlockService";
export class BlockServiceClientImpl implements BlockService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || BlockServiceServiceName;
    this.rpc = rpc;
    this.GetBlockInfo = this.GetBlockInfo.bind(this);
    this.ListBlockErrors = this.ListBlockErrors.bind(this);
    this.PurgeBlocks = this.PurgeBlocks.bind(this);
    this.RetryBlockResync = this.RetryBlockResync.bind(this);
  }
  GetBlockInfo(request: GetBlockInfoRequest): Promise<ApiResponse> {
    const data = GetBlockInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBlockInfo", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  ListBlockErrors(request: ListBlockErrorsRequest): Promise<ApiResponse> {
    const data = ListBlockErrorsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListBlockErrors", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  PurgeBlocks(request: PurgeBlocksRequest): Promise<ApiResponse> {
    const data = PurgeBlocksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PurgeBlocks", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }

  RetryBlockResync(request: RetryBlockResyncRequest): Promise<ApiResponse> {
    const data = RetryBlockResyncRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RetryBlockResync", data);
    return promise.then((data) => ApiResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
